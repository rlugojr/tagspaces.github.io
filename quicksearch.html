<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"js_ioutils.js.html":{"id":"js_ioutils.js.html","title":"Source: js/ioutils.js","body":" TagSpaces API Classes IOAPIIOAPI.ChromeExtensionIOAPI.CordovaIOAPI.FirefoxAddonIOAPI.NWJSIOAPI.WebDAVTSCORE Source: js/ioutils.js /* Copyright (c) 2012-2015 The Tagspaces Authors. All rights reserved. * Use of this source code is governed by a AGPL3 license that * can be found in the LICENSE file. */ /* global define */ /** * Description * @class IOAPI */ define(function(require, exports, module) { 'use strict'; console.log('Loading ioutils.js ...'); var TSCORE = require('tscore'); var TSPOSTIO = require('tspostioapi'); var MAXSEARCHRESULTS = 1000; var stopDirectoryWalking = false; var searchResultsCounter = 0; function walkDirectory(path, options, fileCallback, dirCallback) { return TSCORE.IO.listDirectoryPromise(path, true).then(function(entries) { return Promise.all(entries.map(function(entry) { if (!options) { options = {}; options.recursive = false; } if (entry.isFile) { if (fileCallback) { return fileCallback(entry); } else { return entry; } } else { if (dirCallback) { return dirCallback(entry); } if (options.recursive) { // &amp;&amp; !stopDirectoryWalking &amp;&amp; return walkDirectory(entry.path, options, fileCallback, dirCallback); } else { return entry; } } })); }).catch(function(err) { console.warn(&quot;Error walking directory &quot; + err); return null; }); } function listSubDirectories(dirPath) { console.log(&quot;Listing sub directories: &quot; + dirPath); TSCORE.showLoadingAnimation(); TSCORE.IO.listDirectoryPromise(dirPath).then(function(entries) { var anotatedDirList = []; var firstEntry = 0; // skiping the first entry pointing to the parent directory if (isChrome) { firstEntry = 1; } for (var i = firstEntry; i &lt; entries.length; i++) { if (!entries[i].isFile) { anotatedDirList.push({ &quot;name&quot;: entries[i].name, &quot;path&quot;: entries[i].path }); } } TSPOSTIO.listSubDirectories(anotatedDirList, dirPath); }).catch(function(error) { TSPOSTIO.errorOpeningPath(dirPath); TSCORE.hideLoadingAnimation(); console.error(&quot;Error listDirectory &quot; + dirPath + &quot; error: &quot; + error); }); } function createDirectoryIndex(dirPath) { TSCORE.showWaitingDialog($.i18n.t(&quot;ns.common:waitDialogDiectoryIndexing&quot;)); var directoryIndex = []; TSCORE.IOUtils.walkDirectory(dirPath, {recursive: true}, function(fileEntry) { directoryIndex.push(fileEntry); }).then(function(entries) { TSCORE.hideWaitingDialog(); TSCORE.PerspectiveManager.updateFileBrowserData(directoryIndex); }).catch(function(err) { console.warn(&quot;Error creating index: &quot; + err); TSCORE.hideWaitingDialog(); }); } function deleteFiles(filePathList) { TSCORE.showLoadingAnimation(); var fileDeletionPromises = []; filePathList.forEach(function(filePath) { fileDeletionPromises.push(TSCORE.IO.deleteFilePromise(filePath)); }); Promise.all(fileDeletionPromises).then(function(fList) { fList.forEach(function(filePath) { TSCORE.Meta.updateMetaData(filePath); TSCORE.PerspectiveManager.removeFileUI(filePath); if (filePath === TSCORE.FileOpener.getOpenedFilePath()) { TSCORE.FileOpener.closeFile(true); } }); TSCORE.hideLoadingAnimation(); TSCORE.showSuccessDialog(&quot;Files deleted successfully.&quot;); }, function(error) { TSCORE.hideLoadingAnimation(); TSCORE.showAlertDialog(&quot;Deleting file &quot; + filePath + &quot; failed.&quot;); console.error(&quot;Deleting file &quot; + filePath + &quot; failed &quot; + error); }); } exports.stopDirectoryWalking = stopDirectoryWalking; exports.MAXSEARCHRESULTS = MAXSEARCHRESULTS; exports.walkDirectory = walkDirectory; exports.listSubDirectories = listSubDirectories; exports.createDirectoryIndex = createDirectoryIndex; exports.deleteFiles = deleteFiles; //TODO exports.createTree = createTree; //TODO exports.copyFiles = copyFiles; //TODO exports.moveFiles = moveFiles; }); Ã— Search results Close "},"chromium_chrome.api.js.html":{"id":"chromium_chrome.api.js.html","title":"Source: chromium/chrome.api.js","body":" TagSpaces API Classes IOAPIIOAPI.ChromeExtensionIOAPI.CordovaIOAPI.FirefoxAddonIOAPI.NWJSIOAPI.WebDAVTSCORE Source: chromium/chrome.api.js /* Copyright (c) 2012-2015 The TagSpaces Authors. All rights reserved. * Use of this source code is governed by a AGPL3 license that * can be found in the LICENSE file. */ /* global define, isWin */ /** * A implementation of the IOAPI for the Chrome/Chromium extensions platform * @class ChromeExtension * @memberof IOAPI */ define(function(require, exports, module) { &quot;use strict&quot;; console.log(&quot;Loading Lite chrome.api.js..&quot;); // chrome.browserAction.setBadgeBackgroundColor({ color: '#00ff00' }); // chrome.browserAction.setBadgeText({text: '9999'}); // changing the name of the app $(&quot;#logo&quot;).text(&quot;TagSpaces Lite&quot;); var TSCORE = require(&quot;tscore&quot;); var TSPOSTIO = require(&quot;tspostioapi&quot;); var saveAs = require(&quot;libs/filesaver.js/FileSaver.min&quot;); var dataBegin = &quot;&lt;script&gt;addRow(&quot;; var dataEnd = &quot;);&lt;/script&gt;&quot;; var dataFile = '&quot;,0,&quot;'; var dataDir = '&quot;,1,&quot;'; function checkAccessFileURLAllowed() { chrome.extension.isAllowedFileSchemeAccess(function(isAllowedAccess) { if (!isAllowedAccess) { TSCORE.showAlertDialog($.i18n.t(&quot;ns.dialogs:accessFileURLNotAllowedAlert&quot;)); } }); } function handleStartParameters() { var filePath = TSCORE.Utils.getURLParameter(&quot;open&quot;); if (filePath &amp;&amp; (filePath.length &gt; 0)) { filePath = decodeURIComponent(filePath); console.log(&quot;Opening file in browser: &quot; + filePath); if (filePath.indexOf(&quot;file://&quot;) &gt;= 0) { filePath = filePath.split(&quot;file://&quot;)[1]; } TSCORE.FileOpener.openFileOnStartup(filePath); } } function focusWindow() { // Places the TagSpaces window on top of the windows window.focus(); } function saveSettings(content) { /*chrome.storage.sync.set({'tagSpacesSettings': content}, function() { // Notify that we saved. message('Settings saved'); });*/ } /** * Checks if new version is available * @name checkNewVersion * @method * @memberof IOAPI.ChromeExtension */ function checkNewVersion() { console.log(&quot;Checking for new version...&quot;); var cVer = TSCORE.Config.DefaultSettings.appVersion + &quot;.&quot; + TSCORE.Config.DefaultSettings.appBuild; $.ajax({ url: 'http://tagspaces.org/releases/version.json?cVer=' + cVer, type: 'GET' }) .done(function(data) { TSPOSTIO.checkNewVersion(data); }) .fail(function(data) { console.log(&quot;AJAX failed &quot; + data); }); } /** * Creates recursively a tree structure for a given directory path * @name createDirectoryTree * @method * @memberof IOAPI.ChromeExtension * @param {string} dirPath - the full path of the directory for which the tree will be generated */ function createDirectoryTree(dirPath) { TSCORE.showAlertDialog(&quot;Creating directory tree not supported.&quot;); //var directoyTree = generateDirectoryTree(dirPath); //console.log(JSON.stringify(directoyTree)); //TSPOSTIO.createDirectoryTree(directoyTree); } /** * Creates a list with containing the files and the sub directories of a given directory * @name listDirectoryPromise * @method * @memberof IOAPI.ChromeExtension * @param {string} dirPath - the full path of the directory for which the tree will be generated * @returns {Promise.&lt;Success, Error&gt;} */ function listDirectoryPromise(dirPath) { //console.log(&quot;Listing directory: &quot; + dirPath); return new Promise(function(resolve, reject) { var anotatedDirList = []; $.ajax({ url: &quot;file://&quot; + dirPath, type: 'GET' }) .done(function(data) { var folders = data.substring(data.indexOf(dataBegin) + dataBegin.length, data.lastIndexOf(dataEnd)); folders = folders.split(dataBegin).join(&quot;&quot;); folders = folders.split(dataEnd); var name, path, isFile, fileSize, lastDateModified, fileProp; anotatedDirList = []; // sciping the first entry pointing to the parent directory for (var i = 1; i &lt; folders.length; i++) { //console.log(&quot;Dir &quot; + folders[i]); name = folders[i].substring(2, folders[i].indexOf('&quot;,&quot;')); path = dirPath + TSCORE.dirSeparator + name; isFile = (folders[i].indexOf(dataFile) &gt; 1); fileSize = 0; lastDateModified = 0; if (isFile) { fileProp = folders[i].substring(folders[i].indexOf(dataFile) + dataFile.length + 1, folders[i].length - 1); fileProp = fileProp.split('&quot;,&quot;'); fileSize = fileProp[0]; lastDateModified = fileProp[1]; } anotatedDirList.push({ &quot;name&quot;: name, &quot;isFile&quot;: isFile, &quot;size&quot;: fileSize, &quot;lmdt&quot;: lastDateModified, &quot;path&quot;: path }); } resolve(anotatedDirList); }).fail(function(error) { console.warn(&quot;Error listing files&quot; + JSON.stringify(error)); reject(error); }); }); } /** * Finds out the properties of a file or directory such last modification date or file size * @name getPropertiesPromise * @method * @memberof IOAPI.ChromeExtension * @param {string} filePath - full path to the file or the directory, which will be analysed * @returns {Promise.&lt;Success, Error&gt;} */ function getPropertiesPromise(filePath) { return new Promise(function(resolve, reject) { // TODO use listDirectory to get size and lmdt var fileProperties = {}; fileProperties.path = filePath; fileProperties.size = 0; fileProperties.lmdt = 0; resolve(fileProperties); }); } /** * Load the content of a text file * @name loadTextFilePromise * @method * @memberof IOAPI.ChromeExtension * @param {string} filePath - the full path of the file which will be loaded * @returns {Promise.&lt;Success, Error&gt;} */ function loadTextFilePromise(filePath) { // return getFileContentPromise(filePath, &quot;text&quot;); } /** * Gets the content of file, useful for binary files * @name getFileContentPromise * @method * @memberof IOAPI.ChromeExtension * @param {string} fullPath - the full path of the file which will be loaded * @param {string} type - the type of the XHR response, defaul is *arraybuffer* * @returns {Promise.&lt;Success, Error&gt;} */ function getFileContentPromise(fullPath, type) { console.log(&quot;getFileContentPromise: &quot; + fullPath); return new Promise(function(resolve, reject) { var fileURL = fullPath; if (fileURL.indexOf(&quot;file://&quot;) === -1) { fileURL = &quot;file://&quot; + fileURL; } var xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;, fileURL, true); xhr.responseType = type || &quot;arraybuffer&quot;; xhr.onerror = reject; xhr.onload = function() { var response = xhr.response || xhr.responseText; if (response) { resolve(response); } else { reject(&quot;getFileContentPromise error&quot;); } }; xhr.send(); }); } /** * Persists a given content(binary supported) to a specified filepath * @name saveFilePromise * @method * @memberof IOAPI.ChromeExtension * @param {string} filePath - the full path of the file which should be saved * @param {string} content - content that will be saved * @param {boolean} overwrite - if true existing file path will be overwritten * @returns {Promise.&lt;Success, Error&gt;} */ function saveFilePromise(filePath, content, overwrite) { console.log(&quot;Saving binary file: &quot; + filePath); return new Promise(function(resolve, reject) { overwrite = overwrite || true; if (overwrite) { var blob = new Blob([content], { type: &quot;text/plain;charset=utf-8&quot; }); saveAs(blob, TSCORE.TagUtils.extractFileName(filePath)); } resolve(); }); } /** * Not supported on this platform * @name createDirectoryPromise * @method * @memberof IOAPI.ChromeExtension * @param {string} dirPath - the full path of the folder which will be created * @returns {Promise.&lt;Success, Error&gt;} */ function createDirectoryPromise(dirPath) { return new Promise(function(res, rej) { rej(&quot;Creating directory is not supported in Chrome, please use the desktop version.&quot;); }); } /** * Not supported on this platform * @name renameDirectoryPromise * @method * @memberof IOAPI.ChromeExtension * @returns {Promise.&lt;Success, Error&gt;} */ function renameDirectoryPromise() { return new Promise(function(res, rej) { rej(&quot;Renaming directory is not supported in Chrome, please use the desktop version.&quot;); }); } /** * Not supported on this platform * @name renameFilePromise * @method * @memberof IOAPI.ChromeExtension * @returns {Promise.&lt;Success, Error&gt;} */ function renameFilePromise() { return new Promise(function(res, rej) { rej(&quot;Renaming file is not supported in Chrome, please use the desktop version.&quot;); }); } /** * Not supported on this platform * @name copyFilePromise * @method * @memberof IOAPI.ChromeExtension * @returns {Promise.&lt;Success, Error&gt;} */ function copyFilePromise() { return new Promise(function(res, rej) { rej(&quot;Copy file is not supported in Chrome, please use the desktop version.&quot;); }); } /** * Not supported on this platform * @name deleteFilePromise * @method * @memberof IOAPI.ChromeExtension * @returns {Promise.&lt;Success, Error&gt;} */ function deleteFilePromise() { return new Promise(function(res, rej) { rej(&quot;Creating directory is not supported in Chrome, please use the desktop version.&quot;); }); } /** * Not supported on this platform * @name deleteDirectoryPromise * @method * @memberof IOAPI.ChromeExtension * @returns {Promise.&lt;Success, Error&gt;} */ function deleteDirectoryPromise() { return new Promise(function(res, rej) { rej(&quot;Deleting directory is not supported in Chrome, please use the desktop version.&quot;); }); } /** * Selects a directory with the help of a directory chooser * @name selectDirectory * @method * @memberof IOAPI.ChromeExtension */ function selectDirectory() { console.log(&quot;Select directory!&quot;); var rootPath = &quot;/&quot;; if (isWin) { rootPath = &quot;C:&quot;; } TSCORE.showDirectoryBrowserDialog(rootPath); } /** * Not supported on this platform * @name selectFile * @method * @memberof IOAPI.ChromeExtension */ function selectFile() { // TODO TSCORE.showAlertDialog(&quot;Select file not implemented!&quot;); } /** * Not supported on this platform * @name openDirectory * @method * @memberof IOAPI.ChromeExtension * @param {string} dirPath - the full path of the directory which will be opened */ function openDirectory(dirPath) { // TODO TSCORE.showAlertDialog($.i18n.t(&quot;ns.dialogs:openContainingDirectoryAlert&quot;)); } /** * Not supported on this platform * @name openFile * @method * @memberof IOAPI.ChromeExtension * @param {string} filePath - the full path of the file which will be opened */ function openFile(filePath) { // TODO TSCORE.showAlertDialog($.i18n.t(&quot;ns.dialogs:openFileNativelyAlert&quot;)); } // Platform specific calls exports.checkAccessFileURLAllowed = checkAccessFileURLAllowed; exports.saveSettings = saveSettings; // Platform API exports.handleStartParameters = handleStartParameters; exports.focusWindow = focusWindow; exports.checkNewVersion = checkNewVersion; exports.createDirectoryTree = createDirectoryTree; exports.listDirectoryPromise = listDirectoryPromise; exports.getPropertiesPromise = getPropertiesPromise; exports.loadTextFilePromise = loadTextFilePromise; exports.getFileContentPromise = getFileContentPromise; exports.saveFilePromise = saveFilePromise; exports.saveTextFilePromise = saveFilePromise; exports.saveBinaryFilePromise = saveFilePromise; exports.createDirectoryPromise = createDirectoryPromise; exports.copyFilePromise = copyFilePromise; exports.renameFilePromise = renameFilePromise; exports.renameDirectoryPromise = renameDirectoryPromise; exports.deleteFilePromise = deleteFilePromise; exports.deleteDirectoryPromise = deleteDirectoryPromise; exports.selectFile = selectFile; exports.selectDirectory = selectDirectory; exports.openDirectory = openDirectory; exports.openFile = openFile; }); Ã— Search results Close "},"cordova_cordova.api.js.html":{"id":"cordova_cordova.api.js.html","title":"Source: cordova/cordova.api.js","body":" TagSpaces API Classes IOAPIIOAPI.ChromeExtensionIOAPI.CordovaIOAPI.FirefoxAddonIOAPI.NWJSIOAPI.WebDAVTSCORE Source: cordova/cordova.api.js /* Copyright (c) 2012-2015 The TagSpaces Authors. All rights reserved. * Use of this source code is governed by a AGPL3 license that * can be found in the LICENSE file. */ /* global define */ //cordova ios handleOpenURL is global var handleOpenURL; // jshint ignore:line /** * A implementation of the IOAPI for the Chrome/Chromium extensions platform * @class Cordova * @memberof IOAPI */ define(function(require, exports, module) { &quot;use strict&quot;; console.log(&quot;Loading ioapi.cordova.js..&quot;); var TSCORE = require(&quot;tscore&quot;); var TSPOSTIO = require(&quot;tspostioapi&quot;); var attachFastClick = require('cordova/fastclick/fastclick.min'); var fsRoot; var urlFromIntent; var widgetAction; var loadedSettings, loadedSettingsTags; var appSettingFile = &quot;settings.json&quot;; var appSettingTagsFile = &quot;settingsTags.json&quot;; var anotatedTree; var pendingCallbacks = 0; document.addEventListener(&quot;deviceready&quot;, onDeviceReady, false); document.addEventListener(&quot;resume&quot;, onDeviceResume, false); document.addEventListener(&quot;initApp&quot;, onApplicationLoad, false); // Register ios file open handler handleOpenURL = function(url) { var fileName = url.substring(url.lastIndexOf('/') + 1, url.length); TSCORE.showConfirmDialog(&quot;File copied&quot;, &quot;File &quot; + fileName + &quot; is copied in inbox folder. Would you like to open it ?&quot;, function() { TSCORE.FileOpener.openFile(url); }); }; // Platform specific functions function normalizePath(path) { //we set absoilute path because some extensions didn't recognize cdvfile //but in cordova.api implementation we didn't need absolute path so we strip nativeURL if (path.indexOf(fsRoot.nativeURL) === 0) { path = path.replace(fsRoot.nativeURL , &quot;/&quot;); } if (path.indexOf(fsRoot.fullPath) === 0) { path = path.substring(fsRoot.fullPath.length, path.length); } return path; } function onDeviceReady() { console.log(&quot;Device Ready:&quot;); // &quot;+device.platform+&quot; - &quot;+device.version); // Redefining the back button document.addEventListener(&quot;backbutton&quot;, function(e) { TSCORE.FileOpener.closeFile(); $('.modal').modal('hide'); //e.preventDefault(); }, false); // iOS specific initialization if (isCordovaiOS) { window.plugins = window.plugins || {}; // TODO: use fileOpener2 plugin on all platforms // https://build.phonegap.com/plugins/1117 window.plugins.fileOpener = cordova.plugins.fileOpener2; } if (window.plugins.webintent) { window.plugins.webintent.getUri( function(url) { if (url) { if (&quot;createTXTFile&quot; === url || url.indexOf(&quot;TagSpaces&quot;) &gt; 0) { widgetAction = url; } else { urlFromIntent = url; } } } //, function(error) { // TSCORE.showAlertDialog(&quot;WebIntent Error: &quot; + error); //} ); window.plugins.webintent.onNewIntent(function(url) { widgetAction = url; widgetActionHandler(); }); } attachFastClick(document.body); getFileSystem(); if (isCordovaiOS) { setTimeout(function() { navigator.splashscreen.hide(); }, 1000); //Enable TestFairy if available if (PRODUCTION != &quot;true&quot; &amp;&amp; TestFairy) { TestFairy.begin(&quot;ef5d3fd8bfa17164b8068e71ccb32e1beea25f2f&quot;); } } } function onDeviceResume() { //TODO: reload curtent dir after background operation TSCORE.IO.listDirectory(TSCORE.currentPath); } function widgetActionHandler() { if (TSCORE.currentPath === null) { TSCORE.showAlertDialog(&quot;Please set location folder to use widget&quot;); return; } if (widgetAction === &quot;createTXTFile&quot;) { TSCORE.createTXTFile(); } else { var fileName = widgetAction.substring(widgetAction.lastIndexOf('/'), widgetAction.length); var newFileName = TSCORE.currentPath + fileName; var newFileFullPath = fsRoot.nativeURL + &quot;/&quot; + newFileName; renameFile(widgetAction, newFileName); TSCORE.FileOpener.openFile(newFileFullPath); } widgetAction = undefined; } function onApplicationLoad() { if (widgetAction) { widgetActionHandler(); } } function getFileSystemPromise(path) { console.log(&quot;getFileSystemPromise: &quot; + path); if (path.indexOf(cordova.file.applicationDirectory) === 0) { } else { path = (isCordovaiOS) ? cordova.file.documentsDirectory + &quot;/&quot; + path : &quot;file:///&quot; + path; } return new Promise(function(resolve, reject) { window.resolveLocalFileSystemURL(path, resolve, function(error) { TSCORE.hideLoadingAnimation(); console.error(&quot;Error getting FileSystem: &quot; + JSON.stringify(error)); reject(error); }); }); } function resolveFullPath(localURL) { //Cordova file plugin didn't set fullpath so we set fullpath as absolute //this solve problem with extensions which can't use the cdvfile var URL = &quot;cdvfile://localhost/persistent/&quot;; var fullPath = decodeURIComponent(localURL); if (fullPath.indexOf(&quot;cdvfile://localhost/root/&quot;) === 0) { URL = &quot;cdvfile://localhost/root/&quot;; } fullPath = fsRoot.nativeURL + fullPath.substring(URL.length, fullPath.length); return fullPath; } function getAppStorageFileSystem(fileName, fileCallback, fail) { var dataFolderPath = (isCordovaiOS === true) ? cordova.file.dataDirectory : cordova.file.externalApplicationStorageDirectory; window.resolveLocalFileSystemURL(dataFolderPath, function(fs) { fs.getFile(fileName, {create:true}, fileCallback, fail); }, function(error) { TSCORE.hideLoadingAnimation(); console.error(&quot;Error getSettingsFileSystem: &quot; + JSON.stringify(error)); } ); } function getFileSystem() { //on android cordova.file.externalRootDirectory points to sdcard0 var fsURL = (isCordovaiOS === true) ? cordova.file.documentsDirectory : &quot;file:///&quot;; window.resolveLocalFileSystemURL(fsURL, function(fileSystem) { fsRoot = fileSystem; //console.log(&quot;Filesystem Details: &quot; + JSON.stringify(fsRoot)); handleStartParameters(); loadSettingsFile(appSettingFile, function(settings) { loadedSettings = settings; loadSettingsFile(appSettingTagsFile, function(settingsTags) { loadedSettingsTags = settingsTags; TSCORE.initApp(); }); }); }, function(err) { TSCORE.hideLoadingAnimation(); console.error(&quot;Error resolving local file system url: &quot; + JSON.stringify(err)); } ); } /** * Creates recursively a tree structure for a given directory path * @name generateDirectoryTree * @method * @memberof IOAPI.Cordova * @param {string} entries - //TODO */ function generateDirectoryTree(entries) { var tree = {}; var i; for (i = 0; i &lt; entries.length; i++) { if (entries[i].isFile) { console.log(&quot;File: &quot; + entries[i].name); tree.children.push({ &quot;name&quot;: entries[i].name, &quot;isFile&quot;: entries[i].isFile, &quot;size&quot;: &quot;&quot;, // TODO size and lmtd &quot;lmdt&quot;: &quot;&quot;, // &quot;path&quot;: entries[i].fullPath }); } else { var directoryReader = entries[i].createReader(); pendingCallbacks++; directoryReader.readEntries( generateDirectoryTree, function(error) { TSCORE.hideLoadingAnimation(); console.error(&quot;Error reading dir entries: &quot; + error.code); }); // jshint ignore:line } } pendingCallbacks--; console.log(&quot;Pending recursions: &quot; + pendingCallbacks); if (pendingCallbacks &lt;= 0) { TSPOSTIO.createDirectoryTree(anotatedTree); } } function saveSettingsFile(fileName, data) { getAppStorageFileSystem(fileName, function(fileEntry) { fileEntry.createWriter( function(writer) { writer.write(data); }, function(error) { TSCORE.hideLoadingAnimation(); console.error(&quot;Error creating writter: &quot; + JSON.stringify(error)); } ); }, function(error) { TSCORE.hideLoadingAnimation(); console.error(&quot;Error getting app storage file system: &quot; + JSON.stringify(error)); } ); } function loadSettingsFile(fileName, ready) { getAppStorageFileSystem(fileName, function(fileEntry) { fileEntry.file( function(file) { var reader = new FileReader(); reader.onloadend = function(evt) { var content = null; if (evt.target.result.length &gt; 0) { content = evt.target.result; } ready(content); }; reader.readAsText(file); }, function(error) { TSCORE.hideLoadingAnimation(); console.error(&quot;Error reading file: &quot; + JSON.stringify(error)); } ); }, function(error) { TSCORE.hideLoadingAnimation(); console.log(&quot;Error getting app storage file system: &quot; + JSON.stringify(error)); } ); } // Platform specific API calls function saveSettings(settings) { // saveSettingsFile(appSettingFile, settings); } function loadSettings() { // return loadedSettings; } function saveSettingsTags(tagGroups) { //TODO use js objects var jsonFormat = '{ &quot;appName&quot;: &quot;' + TSCORE.Config.DefaultSettings.appName + '&quot;, &quot;appVersion&quot;: &quot;' + TSCORE.Config.DefaultSettings.appVersion + '&quot;, &quot;appBuild&quot;: &quot;' + TSCORE.Config.DefaultSettings.appBuild + '&quot;, &quot;settingsVersion&quot;: ' + TSCORE.Config.DefaultSettings.settingsVersion + ', &quot;tagGroups&quot;: ' + tagGroups + ' }'; saveSettingsFile(appSettingTagsFile, jsonFormat); } function loadSettingsTags() { return loadedSettingsTags; } function sendFile(filePath) { console.log(&quot;Sending file: &quot; + filePath); window.plugins.fileOpener.send(filePath); } // Platform API /** * Checks if new version is available * @name checkNewVersion * @method * @memberof IOAPI.Cordova */ function checkNewVersion() { console.log(&quot;Checking for new version...&quot;); var cVer = TSCORE.Config.DefaultSettings.appVersion + &quot;.&quot; + TSCORE.Config.DefaultSettings.appBuild; $.ajax({ url: 'http://tagspaces.org/releases/version.json?pVer=' + cVer, type: 'GET' }) .done(function(data) { TSPOSTIO.checkNewVersion(data); }) .fail(function(data) { console.log(&quot;AJAX failed &quot; + data); }); } /** *Bring the TagSpaces window on top of the windows *@name focusWindow *mthod *@memberof IOAPI.Cordova */ function focusWindow() { // Bring the TagSpaces window on top of the windows console.log(&quot;Focusing window is not implemented in cordova.&quot;); } //TODO function handleStartParameters() { if (urlFromIntent !== undefined &amp;&amp; urlFromIntent.length &gt; 0) { console.log(&quot;Intent URL: &quot; + urlFromIntent); var filePath = decodeURIComponent(urlFromIntent); TSCORE.FileOpener.openFileOnStartup(filePath); } } /** * Creates recursively a tree structure for a given directory path * @name createDirectoryTree * @method * @memberof IOAPI.Cordova * @param {string} dirPath - the full path of the directory for which the tree will be generated */ function createDirectoryTree(dirPath) { // TODO TSCORE.hideLoadingAnimation(); TSCORE.showAlertDialog(&quot;Creating directory tree is not supported in Cordova yet.&quot;); } /** * Creates a list with containing the files and the sub directories of a given directory * @name listDirectoryPromise * @method * @memberof IOAPI.Cordova * @param {string} path - the directory path for which the list will be created * @param {boolean} lite - if true the path to a file thumbnails will be not included in the results * This will increase the performance of the function. * @returns {Promise.&lt;Success, Error&gt;} */ function listDirectoryPromise(path, lite) { console.time(&quot;listDirectoryPromise&quot;); return new Promise(function(resolve, reject) { var anotatedDirList = []; var fileWorkers = []; getFileSystemPromise(path).then(function(fileSystem) { var reader = fileSystem.createReader(); reader.readEntries( function(entries) { entries.forEach(function(entry) { if (entry.isDirectory) { anotatedDirList.push({ &quot;name&quot;: entry.name, &quot;path&quot;: entry.fullPath, &quot;isFile&quot;: false, &quot;size&quot;: &quot;&quot;, &quot;lmdt&quot;: &quot;&quot; }); } else if (entry.isFile) { if (lite) { anotatedDirList.push({ &quot;name&quot;: entry.name, &quot;path&quot;: entry.fullPath, &quot;isFile&quot;: true, &quot;size&quot;: &quot;&quot;, &quot;lmdt&quot;: &quot;&quot; }); } else { var filePromise = Promise.resolve({ then: function(onFulfill, onReject) { entry.file( function(fileEntry) { if (!fileEntry.fullPath) { fileEntry.fullPath = resolveFullPath(fileEntry.localURL); } anotatedDirList.push(); onFulfill({ &quot;name&quot;: fileEntry.name, &quot;isFile&quot;: true, &quot;size&quot;: fileEntry.size, &quot;lmdt&quot;: fileEntry.lastModifiedDate, &quot;path&quot;: fileEntry.fullPath }); }, function(err) { onReject(&quot;Error reading entry &quot; + path); }); } }); // jshint ignore:line fileWorkers.push(filePromise); } } }); Promise.all(fileWorkers).then(function(entries) { entries.forEach(function(entry) { anotatedDirList.push(entry); }); console.timeEnd(&quot;listDirectoryPromise&quot;); resolve(anotatedDirList); }, function(err) { console.warn(&quot;At least one file worker failed for &quot; + path + &quot;err &quot; + JSON.stringify(err)); console.timeEnd(&quot;listDirectoryPromise&quot;); resolve(anotatedDirList); // returning results even if any promise fails }); }, function(err) { console.warn(&quot;Error reading entries promise from &quot; + path + &quot;err &quot; + JSON.stringify(err)); resolve(anotatedDirList); // returning results even if any promise fails } ); }, function() { console.warn(&quot;Error getting file system promise&quot;); resolve(anotatedDirList); // returning results even if any promise fails } ); }); } /** * Finds out the properties of a file or directory such last modification date or file size * @name getPropertiesPromise * @method * @memberof IOAPI.Cordova * @param {string} filePath - full path to the file or the directory, which will be analysed * @returns {Promise.&lt;Success, Error&gt;} */ function getPropertiesPromise(filePath) { return new Promise(function(resolve, reject) { filePath = normalizePath(filePath); //getFileSystemPromise(dir).then(function(fileSystem) { var fileProperties = {}; fsRoot.getFile(filePath, { create: false, exclusive: false }, function(entry) { if (entry.isFile) { entry.file( function(file) { fileProperties.path = entry.fullPath; fileProperties.size = file.size; fileProperties.lmdt = file.lastModifiedDate; fileProperties.mimetype = file.type; resolve(fileProperties); }, function() { console.log(&quot;getPropertiesPromise: Error retrieving file properties of &quot; + filePath); resolve(false); } ); } else { console.log(&quot;getPropertiesPromise: Error getting file properties. &quot; + filePath + &quot; is directory&quot;); resolve(false); } }, function() { console.log(&quot;getPropertiesPromise: Error getting file &quot; + filePath); resolve(false); } ); }); //}); } /** * Load the content of a text file * @name loadTextFilePromise * @method * @memberof IOAPI.Cordova * @param {string} filePath - the full path of the file which will be loaded * @returns {Promise.&lt;Success, Error&gt;} */ function loadTextFilePromise(filePath) { // return getFileContentPromise(filePath, &quot;text&quot;); } /** * Gets the content of file, useful for binary files * @name getFileContentPromise * @method * @memberof IOAPI.Cordova * @param {string} fullPath - the full path of the file which will be loaded * @param {string} type - the type of the XHR response, defaul is *arraybuffer* * @returns {Promise.&lt;Success, Error&gt;} */ function getFileContentPromise(filePath, type, resolvePath) { // TODO refactor var getFilePromise = function(filePath, resolvePath) { var getFile = function(fullPath, result, fail) { var filePath = normalizePath(fullPath); fsRoot.getFile(filePath, {create: false}, function(fileEntry) { fileEntry.file(function(file) { result(file); }, fail); }, fail ); }; return new Promise(function(resolve, reject) { if (resolvePath) { getFileSystemPromise(resolvePath).then(function(resfs) { resfs.getFile(filePath, {create: false}, function(fileEntry) { fileEntry.file(resolve, reject); }, reject ); }).catch(reject); } else { getFile(filePath, resolve, reject); } }); }; return new Promise(function(resolve, reject) { getFilePromise(filePath, resolvePath).then(function(file) { var reader = new FileReader(); reader.onerror = function() { reject(reader.error); }; reader.onload = function() { resolve(reader.result); }; if (type === &quot;text&quot;) { reader.readAsText(file); } else { reader.readAsArrayBuffer(file); } }, reject); }); } /** * Persists a given content(binary supported) to a specified filepath * @name saveFilePromise * @method * @memberof IOAPI.Cordova * @param {string} filePath - the full path of the file which should be saved * @param {string} content - content that will be saved * @param {boolean} overWrite - if true existing file path will be overwritten * @returns {Promise.&lt;Success, Error&gt;} */ function saveFilePromise(filePath, content, overWrite) { console.log(&quot;Saving file: &quot; + filePath); return new Promise(function(resolve, reject) { var isFileNew = true; filePath = normalizePath(filePath); // Checks if the file already exists fsRoot.getFile(filePath, { create: false, exclusive: false }, function(entry) { if (entry.isFile) { isFileNew = false; } }, function() {} ); if (isFileNew || overWrite === true) { fsRoot.getFile(filePath, { create: true, exclusive: false }, function(entry) { entry.createWriter( function(writer) { writer.onwriteend = function(evt) { //resolve(fsRoot.fullPath + &quot;/&quot; + filePath); resolve(isFileNew); }; writer.write(content); }, function() { reject(&quot;error creating writter file: &quot; + filePath); } ); }, function() { reject(&quot;Error getting file entry: &quot; + filePath); } ); } else { var errMsg = $.i18n.t(&quot;ns.common:fileExists&quot;, {fileName:filePath}); TSCORE.showAlertDialog(errMsg); reject(errMsg); } }); } /** * Persists a given text content to a specified filepath * @name saveTextFilePromise * @method * @memberof IOAPI.Cordova * @param {string} filePath - the full path of the file which will be saved * @param {string} content - content that will be saved * @param {string} overWrite - if true existing file path will be overwritten * @returns {Promise.&lt;Success, Error&gt;} */ function saveTextFilePromise(filePath, content, overWrite) { console.log(&quot;Saving file: &quot; + filePath); // Handling the UTF8 support for text files var UTF8_BOM = &quot;\\ufeff&quot;; if (content.indexOf(UTF8_BOM) === 0) { console.log(&quot;Content beging with a UTF8 bom&quot;); } else { content = UTF8_BOM + content; } return saveFilePromise(filePath, content, overWrite); } /** * Persists a given binary content to a specified filepath * @name saveBinaryFilePromise * @method * @memberof IOAPI.Cordova * @param {string} filePath - the full path of the file which will be saved * @param {string} content - content that will be saved * @param {string} overWrite - if true existing file path will be overwritten * @returns {Promise.&lt;Success, Error&gt;} */ function saveBinaryFilePromise(filePath, content, overWrite) { console.log(&quot;Saveing binary file: &quot; + filePath); var dataView = new Int8Array(content); return saveFilePromise(filePath, dataView, overWrite); } /** * Creates a directory * @name createDirectoryPromise * @method * @memberof IOAPI.Cordova * @param {string} dirPath - the full path of the folder which will be created * @returns {Promise.&lt;Success, Error&gt;} */ function createDirectoryPromise(dirPath) { console.log(&quot;Creating directory: &quot; + dirPath); return new Promise(function(resolve, reject) { dirPath = normalizePath(dirPath); fsRoot.getDirectory(dirPath, { create: true, exclusive: false }, function(dirEntry) { resolve(dirPath); }, function(error) { reject(&quot;Creating directory failed: &quot; + dirPath + &quot; failed with error code: &quot; + error.code); } ); }); } /** * Copies a given file to a specified location * @name copyFilePromise * @method * @memberof IOAPI.Cordova * @param {string} filePath - the full path of a file which will be copied * @param {string} newFilePath - the full path destination of the copied file * @returns {Promise.&lt;Success, Error&gt;} */ function copyFilePromise(filePath, newFilePath) { return new Promise(function(resolve, reject) { filePath = normalizePath(filePath); var newFileName = newFilePath.substring(newFilePath.lastIndexOf('/') + 1); var newFileParentPath = normalizePath(newFilePath.substring(0, newFilePath.lastIndexOf('/'))); // TODO check if the newFilePath exist or causes issues by copying fsRoot.getDirectory(newFileParentPath, { create: false, exclusive: false }, function(parentDirEntry) { fsRoot.getFile(filePath, { create: false, exclusive: false }, function(entry) { entry.copyTo( parentDirEntry, newFileName, function() { console.log(&quot;File copy: target: &quot; + newFilePath + &quot; source: &quot; + entry.fullPath); resolve(newFilePath); }, function() { reject(&quot;error copying: &quot; + filePath); } ); }, function() { reject(&quot;Error getting file: &quot; + filePath); } ); }, function(error) { reject(&quot;Getting dir: &quot; + newFileParentPath + &quot; failed with error code: &quot; + error.code); } ); }); } /** * Renames a given file * @name renameFilePromise * @method * @memberof IOAPI.Cordova * @param {string} filePath - the full path of the file which will be renamed * @param {string} newFilePath - the desired full path after the file rename * @returns {Promise.&lt;Success, Error&gt;} */ function renameFilePromise(filePath, newFilePath) { return new Promise(function(resolve, reject) { filePath = normalizePath(filePath); var newFileName = newFilePath.substring(newFilePath.lastIndexOf('/') + 1); var newFileParentPath = normalizePath(newFilePath.substring(0, newFilePath.lastIndexOf('/') + 1)); console.log(&quot;renameFile: &quot; + newFileName + &quot; newFilePath: &quot; + newFilePath); // TODO check if the newFilePath exist or causes issues by renaming fsRoot.getDirectory(newFileParentPath, { create: false, exclusive: false }, function(parentDirEntry) { fsRoot.getFile(filePath, { create: false, exclusive: false }, function(entry) { entry.moveTo( parentDirEntry, newFileName, function() { console.log(&quot;File renamed to: &quot; + newFilePath + &quot; Old name: &quot; + entry.fullPath); resolve([filePath, newFilePath]); }, function() { reject(&quot;error renaming: &quot; + filePath); } ); }, function() { reject(&quot;Error getting file: &quot; + filePath); } ); }, function(error) { console.error(&quot;Getting dir: &quot; + newFileParentPath + &quot; failed with error code: &quot; + error.code); reject(error); } ); }); } /** * Rename a directory * @name renameDirectoryPromise * @method * @memberof IOAPI.Cordova * @param {string} dirPath - the full path of the directory which will be renamed * @param {string} newDirName - the desired full path after the directory rename * @returns {Promise.&lt;Success, Error&gt;} */ function renameDirectoryPromise(dirPath, newDirName) { return new Promise(function(resolve, reject) { var newDirPath = TSCORE.TagUtils.extractParentDirectoryPath(dirPath) + TSCORE.dirSeparator + newDirName; TSCORE.showLoadingAnimation(); dirPath = normalizePath(dirPath); var newDirParentPath = normalizePath(newDirPath.substring(0, newDirPath.lastIndexOf('/'))); console.log(&quot;renameDirectoryPromise: &quot; + dirPath + &quot; to: &quot; + newDirPath); // TODO check if the newFilePath exist or cause issues by renaming fsRoot.getDirectory(newDirParentPath, { create: false, exclusive: false }, function(parentDirEntry) { fsRoot.getDirectory(dirPath, { create: false, exclusive: false }, function(entry) { entry.moveTo( parentDirEntry, newDirName, function() { console.log(&quot;Directory renamed to: &quot; + newDirPath + &quot; Old name: &quot; + entry.fullPath); resolve(newDirPath); }, function() { reject(&quot;error renaming: &quot; + dirPath); } ); }, function() { reject(&quot;Error getting directory: &quot; + dirPath); } ); }, function(error) { console.error(&quot;Getting dir: &quot; + newDirParentPath + &quot; failed with error code: &quot; + error.code); reject(error); } ); }); } /** * Delete a specified file * @name deleteFilePromise * @method * @memberof IOAPI.Cordova * @param {string} filePath - the full path of the file which will be deleted * @returns {Promise.&lt;Success, Error&gt;} */ function deleteFilePromise(filePath) { return new Promise(function(resolve, reject) { var path = normalizePath(filePath); fsRoot.getFile(path, { create: false, exclusive: false }, function(entry) { entry.remove( function() { console.log(&quot;file deleted: &quot; + path); resolve(filePath); }, function() { reject(&quot;error deleting: &quot; + filePath); } ); }, function() { reject(&quot;error getting file&quot;); } ); }); } /** * Delete a specified directory, the directory should be empty, if the trash can functionality is not enabled * @name deleteDirectoryPromise * @method * @memberof IOAPI.Cordova * @param {string} dirPath - the full path of the directory which will be deleted * @returns {Promise.&lt;Success, Error&gt;} */ function deleteDirectoryPromise(dirPath) { console.log(&quot;Deleting directory: &quot; + dirPath); return new Promise(function(resolve, reject) { var path = normalizePath(dirPath); fsRoot.getDirectory(path, { create: false, exclusive: false }, function(entry) { entry.remove( function() { console.log(&quot;file deleted: &quot; + path); resolve(dirPath); }, function() { //TSCORE.hideLoadingAnimation(); //TSPOSTIO.deleteDirectoryFailed(path); reject(&quot;error deleting dir: &quot; + dirPath); } ); }, function() { reject(&quot;error getting directory &quot; + dirPath); } ); }); } /** * Selects a directory with the help of a directory chooser * @name selectDirectory * @method * @memberof IOAPI.Cordova */ function selectDirectory() { console.log(&quot;Open select directory dialog.&quot;); TSCORE.showDirectoryBrowserDialog(fsRoot.fullPath); } /** * Selects a file with the help of a file chooser * @name selectFile * @method * @memberof IOAPI.Cordova */ function selectFile() { // console.log(&quot;Operation selectFile not supported.&quot;); } /** * Opens a directory in the operating system's default file manager * @name openDirectory * @method * @memberof IOAPI.Cordova * @param {string} dirPath - the full path of the directory which will be opened * @returns {Promise.&lt;Success, Error&gt;} */ function openDirectory(dirPath) { TSCORE.showAlertDialog($.i18n.t(&quot;ns.dialogs:openContainingDirectoryAlert&quot;)); } /** * Opens a file with the operating system's default program for the type of the file * @name openFile * @method * @memberof IOAPI.Cordova * @param {string} filePath - the full path of the file which will be opened */ function openFile(filePath) { console.log(&quot;Opening natively: &quot; + filePath); window.plugins.fileOpener.open(filePath); } // Platform specific API calls exports.saveSettings = saveSettings; exports.loadSettings = loadSettings; exports.saveSettingsTags = saveSettingsTags; exports.loadSettingsTags = loadSettingsTags; exports.sendFile = sendFile; // Platform API exports.checkNewVersion = checkNewVersion; exports.focusWindow = focusWindow; exports.handleStartParameters = handleStartParameters; exports.createDirectoryTree = createDirectoryTree; exports.listDirectoryPromise = listDirectoryPromise; exports.getPropertiesPromise = getPropertiesPromise; exports.loadTextFilePromise = loadTextFilePromise; exports.getFileContentPromise = getFileContentPromise; exports.saveFilePromise = saveFilePromise; exports.saveTextFilePromise = saveTextFilePromise; exports.saveBinaryFilePromise = saveBinaryFilePromise; exports.createDirectoryPromise = createDirectoryPromise; exports.copyFilePromise = copyFilePromise; exports.renameFilePromise = renameFilePromise; exports.renameDirectoryPromise = renameDirectoryPromise; exports.deleteFilePromise = deleteFilePromise; exports.deleteDirectoryPromise = deleteDirectoryPromise; exports.selectDirectory = selectDirectory; exports.selectFile = selectFile; exports.openDirectory = openDirectory; exports.openFile = openFile; }); Ã— Search results Close "},"mozilla_mozilla.api.js.html":{"id":"mozilla_mozilla.api.js.html","title":"Source: mozilla/mozilla.api.js","body":" TagSpaces API Classes IOAPIIOAPI.ChromeExtensionIOAPI.CordovaIOAPI.FirefoxAddonIOAPI.NWJSIOAPI.WebDAVTSCORE Source: mozilla/mozilla.api.js /* Copyright (c) 2012-2015 The TagSpaces Authors. All rights reserved. * Use of this source code is governed by a AGPL3 license that * can be found in the LICENSE file. */ /* global define */ /** * A implementation of the IOAPI for the Chrome/Chromium extensions platform * @class FirefoxAddon * @memberof IOAPI */ define(function(require, exports, module) { &quot;use strict&quot;; console.log(&quot;Loading mozilla.api.js..&quot;); var TSCORE = require(&quot;tscore&quot;); var TSPOSTIO = require(&quot;tspostioapi&quot;); var args = []; document.documentElement.addEventListener(&quot;tsMessage&quot;, function(event) { console.log(&quot;Message received in page script from content script&quot;); //+JSON.stringify(event.detail)); var message = event.detail; switch (message.command) { case &quot;loadSettings&quot;: if (message.success) { try { console.log(&quot;Loading settings...: &quot; + JSON.stringify(message.content)); TSCORE.Config.updateSettingMozillaPreferences(message.content); TSCORE.initLocations(); TSCORE.generateTagGroups(); } catch (ex) { console.log(&quot;Exception while getting setting from firefox failed &quot; + ex); } } else { console.log(&quot;Getting setting from firefox failed&quot;); } break; case &quot;saveSettings&quot;: if (message.success) { console.log(&quot;Saving setting as native mozilla preference successfull!&quot;); } else { console.log(&quot;Saving setting as native mozilla preference failed!&quot;); } break; case &quot;createDirectoryTree&quot;: if (message.success) { console.log(&quot;Directory tree: &quot; + JSON.stringify(message.content)); TSPOSTIO.createDirectoryTree(message.content); } else { console.error(&quot;Indexing directory failed&quot;); } break; case &quot;selectDirectory&quot;: if (message.success) { TSPOSTIO.selectDirectory(message.content); } else { console.error(&quot;Selecting directory failed.&quot;); } break; case &quot;checkNewVersion&quot;: if (message.success) { TSPOSTIO.checkNewVersion(message.content); } else { console.error(&quot;Checking for new version failed.&quot;); } break; default: break; } }, false); function base64toArrayBuffer(str) { var bstr = atob(str); var len = bstr.length; var bytes = new Uint8Array(len); for (var i = 0; i &lt; len; i++) { bytes[i] = bstr.charCodeAt(i); } return bytes.buffer; } function ab2str(buf) { //TODO add support for larger files // http://updates.html5rocks.com/2014/08/Easier-ArrayBuffer---String-conversion-with-the-Encoding-API return String.fromCharCode.apply(null, new Uint8Array(buf)); } function focusWindow() { // Bring the TagSpaces window on top of the windows window.focus(); } function saveSettings(content) { console.log(&quot;Saving setting...&quot;); var event = document.createEvent('CustomEvent'); event.initCustomEvent(&quot;addon-message&quot;, true, true, { &quot;detail&quot;: { &quot;command&quot;: &quot;saveSettings&quot;, &quot;content&quot;: content } }); document.documentElement.dispatchEvent(event); } function loadSettings() { console.log(&quot;Loading setting from firefox preferences...&quot;); var event = document.createEvent('CustomEvent'); event.initCustomEvent(&quot;addon-message&quot;, true, true, { &quot;detail&quot;: { &quot;command&quot;: &quot;loadSettings&quot; } }); document.documentElement.dispatchEvent(event); } /** * Checks if new version is available * @name checkNewVersion * @method * @memberof IOAPI.FirefoxAddon */ function checkNewVersion() { console.log(&quot;Checking for new version...&quot;); var event = document.createEvent('CustomEvent'); event.initCustomEvent(&quot;addon-message&quot;, true, true, { &quot;detail&quot;: { &quot;command&quot;: &quot;checkNewVersion&quot; } }); document.documentElement.dispatchEvent(event); } /** * Creates a list with containing the files and the sub directories of a given directory * @name listDirectoryPromise * @method * @memberof IOAPI.FirefoxAddon * @param {string} dirPath - the directory path which is listed * @returns {Promise.&lt;Success, Error&gt;} */ function listDirectoryPromise(dirPath) { return new Promise(function(resolve, reject) { console.log(&quot;Listing directory: &quot; + dirPath); var event = document.createEvent('CustomEvent'); event.initCustomEvent(&quot;addon-message&quot;, true, true, { &quot;detail&quot;: { &quot;command&quot;: &quot;listDirectory&quot;, &quot;path&quot;: dirPath } }); document.documentElement.dispatchEvent(event); function eventListener(event) { var message = event.detail; if (message.command === &quot;listDirectory&quot;) { if (message.success) { resolve(message.content); } else { reject(&quot;listDirectory&quot; + dirPath + &quot; failed&quot;); } document.documentElement.removeEventListener(&quot;tsMessage&quot;, eventListener); } } document.documentElement.addEventListener(&quot;tsMessage&quot;, eventListener); }); } /** * Finds out the properties of a file or directory such last modification date or file size * @name getPropertiesPromise * @method * @memberof IOAPI.FirefoxAddon * @param {string} filePath - full path to the file or the directory, which will be analysed * @returns {Promise.&lt;Success, Error&gt;} */ function getPropertiesPromise(filePath) { console.log(&quot;Getting file properties...&quot;); return new Promise(function(resolve, reject) { var event = document.createEvent('CustomEvent'); event.initCustomEvent(&quot;addon-message&quot;, true, true, { &quot;detail&quot;: { &quot;command&quot;: &quot;getFileProperties&quot;, &quot;path&quot;: filePath } }); document.documentElement.dispatchEvent(event); function eventListener(event) { console.log(&quot;Message received in page script from content script&quot;); //+JSON.stringify(event.detail)); var message = event.detail; if (message.command === &quot;getFileProperties&quot;) { if (message.success) { resolve(message.content); } else { reject(&quot;Getting file properties failed&quot;); } document.documentElement.removeEventListener(&quot;tsMessage&quot;, eventListener); } } document.documentElement.addEventListener(&quot;tsMessage&quot;, eventListener); }); } /** * Creates recursively a tree structure for a given directory path * @name createDirectoryTree * @method * @memberof IOAPI.FirefoxAddon * @param {string} dirPath - the full path of the directory for which the tree will be generated */ function createDirectoryTree(dirPath) { console.log(&quot;Creating directory tree for: &quot; + dirPath); var event = document.createEvent('CustomEvent'); event.initCustomEvent(&quot;addon-message&quot;, true, true, { &quot;detail&quot;: { &quot;command&quot;: &quot;createDirectoryTree&quot;, &quot;path&quot;: dirPath } }); document.documentElement.dispatchEvent(event); } /** * Load the content of a text file * @name loadTextFilePromise * @method * @memberof IOAPI.FirefoxAddon * @param {string} filePath - the full path of the file which will be loaded * @returns {Promise.&lt;Success, Error&gt;} */ function loadTextFilePromise(filePath) { // return getFileContentPromise(filePath, &quot;text&quot;); } /** * Gets the content of file, useful for binary files * @name getFileContentPromise * @method * @memberof IOAPI.FirefoxAddon * @param {string} fullPath - the full path of the file which will be loaded * @param {string} type - the type of the XHR response, defaul is *arraybuffer* * @returns {Promise.&lt;Success, Error&gt;} */ function getFileContentPromise(filePath, type) { console.log(&quot;getFileContentPromise: &quot; + filePath); return new Promise(function(resolve, reject) { var event = document.createEvent('CustomEvent'); var command = (type === &quot;text&quot;) ? &quot;loadTextFile&quot; : &quot;getFileContent&quot;; event.initCustomEvent(&quot;addon-message&quot;, true, true, { &quot;detail&quot;: { &quot;command&quot;: command, &quot;path&quot;: filePath } }); document.documentElement.dispatchEvent(event); function eventListener(event) { console.log(&quot;Message received in page script from content script&quot;); //+JSON.stringify(event.detail)); var message = event.detail; if (message.command === command) { if (message.success) { if(message.command === &quot;getFileContent&quot;) { //TODO: fix buffer conversion var arrBuff = base64toArrayBuffer(message.content); resolve(arrBuff); } else { resolve(message.content); } } else { reject(&quot;File content loading failed&quot;); } document.documentElement.removeEventListener(&quot;tsMessage&quot;, eventListener); } } document.documentElement.addEventListener(&quot;tsMessage&quot;, eventListener); }); } /** * Persists a given content(binary supported) to a specified filepath * @name saveFilePromise * @method * @memberof IOAPI.FirefoxAddon * @param {string} filePath - the full path of the file which should be saved * @param {string} content - content that will be saved * @param {boolean} overWrite - if true existing file path will be overwritten * @returns {Promise.&lt;Success, Error&gt;} */ function saveFilePromise(filePath, content, overWrite) { return new Promise(function(resolve, reject) { console.log(&quot;Saving file: &quot; + filePath); var event = document.createEvent('CustomEvent'); event.initCustomEvent(&quot;addon-message&quot;, true, true, { &quot;detail&quot;: { &quot;command&quot;: &quot;saveTextFile&quot;, &quot;path&quot;: filePath, &quot;content&quot;: content, &quot;overwrite&quot;: overWrite } }); document.documentElement.dispatchEvent(event); function eventListener(event) { var message = event.detail; if (message.command === &quot;saveTextFile&quot;) { if (message.success) { resolve(message.content); } else { reject(&quot;Save text file failed&quot;); } document.documentElement.removeEventListener(&quot;tsMessage&quot;, eventListener); } } document.documentElement.addEventListener(&quot;tsMessage&quot;, eventListener); }); } /** * Persists a given binary content to a specified filepath * @name saveBinaryFilePromise * @method * @memberof IOAPI.FirefoxAddon * @param {string} filePath - the full path of the file which will be saved * @param {string} content - content that will be saved * @param {string} overWrite - if true existing file path will be overwritten * @returns {Promise.&lt;Success, Error&gt;} */ function saveBinaryFilePromise(filePath, content, overWrite) { return new Promise(function(resolve, reject) { console.log(&quot;Saving binary file post: &quot; + filePath); //+&quot; - &quot;+content); var event = document.createEvent('CustomEvent'); event.initCustomEvent(&quot;addon-message&quot;, true, true, { &quot;detail&quot;: { &quot;command&quot;: &quot;saveBinaryFile&quot;, &quot;path&quot;: filePath, &quot;content&quot;: ab2str(content), &quot;overwrite&quot;: overWrite } }); document.documentElement.dispatchEvent(event); function eventListener(event) { var message = event.detail; if (message.command === &quot;saveBinaryFile&quot;) { if (message.success) { resolve(message.content); } else { reject(&quot;Save bin file failed&quot;); } document.documentElement.removeEventListener(&quot;tsMessage&quot;, eventListener); } } document.documentElement.addEventListener(&quot;tsMessage&quot;, eventListener); }); } /** * Creates a directory * @name createDirectory * @method * @memberof IOAPI.FirefoxAddon * @param {string} dirPath - the full path of the folder which will be created * @param {string} silentMode - //TODO */ function createDirectory(dirPath, silentMode) { createDirectoryPromise(dirPath).then(function() { if(!silentMode) { TSPOSTIO.createDirectory(dirPath); } }, function(error){ console.log(error); }); } /** * Creates a directory * @name createDirectoryPromise * @method * @memberof IOAPI.FirefoxAddon * @param {string} dirPath - the full path of the folder which will be created * @returns {Promise.&lt;Success, Error&gt;} */ function createDirectoryPromise(dirPath) { return new Promise(function(resolve, reject) { console.log(&quot;Directory &quot; + dirPath + &quot; created.&quot;); var event = document.createEvent('CustomEvent'); event.initCustomEvent(&quot;addon-message&quot;, true, true, { &quot;detail&quot;: { &quot;command&quot;: &quot;createDirectory&quot;, &quot;path&quot;: dirPath } }); document.documentElement.dispatchEvent(event); function eventListener(event) { var message = event.detail; if (message.command === &quot;createDirectory&quot;) { if (message.success) { resolve(message.content); } else { reject(&quot;Create directory failed&quot;); } document.documentElement.removeEventListener(&quot;tsMessage&quot;, eventListener); } } document.documentElement.addEventListener(&quot;tsMessage&quot;, eventListener); }); } /** * Copies a given file to a specified location * @name copyFilePromise * @method * @memberof IOAPI.FirefoxAddon * @param {string} filePath - the full path of a file which will be copied * @param {string} newFilePath - the full path destination of the copied file * @returns {Promise.&lt;Success, Error&gt;} */ function copyFilePromise(filePath, newFilePath) { return new Promise(function(resolve, reject) { console.log(&quot;Copy &quot; + filePath + &quot; to &quot; + newFilePath); var event = document.createEvent('CustomEvent'); event.initCustomEvent(&quot;addon-message&quot;, true, true, { &quot;detail&quot;: { &quot;command&quot;: &quot;copy&quot;, &quot;path&quot;: filePath, &quot;newPath&quot;: newFilePath } }); document.documentElement.dispatchEvent(event); function eventListener(event) { var message = event.detail; if (message.command === &quot;copy&quot;) { if (message.success) { resolve(message.content); } else { reject(&quot;Copy file failed&quot;); } document.documentElement.removeEventListener(&quot;tsMessage&quot;, eventListener); } } document.documentElement.addEventListener(&quot;tsMessage&quot;, eventListener); }); } /** * Renames a given file * @name renameFilePromise * @method * @memberof IOAPI.FirefoxAddon * @param {string} filePath - the full path of the file which will be renamed * @param {string} newPath - the desired full path after the file rename * @returns {Promise.&lt;Success, Error&gt;} */ function renameFilePromise(filePath, newPath) { return new Promise(function(resolve, reject) { console.log(&quot;Renaming &quot; + filePath + &quot; to &quot; + newFilePath); var event = document.createEvent('CustomEvent'); event.initCustomEvent(&quot;addon-message&quot;, true, true, { &quot;detail&quot;: { &quot;command&quot;: &quot;rename&quot;, &quot;path&quot;: filePath, &quot;newPath&quot;: newFilePath } }); document.documentElement.dispatchEvent(event); function eventListener(event) { var message = event.detail; if (message.command === &quot;rename&quot;) { if (message.success) { resolve(message.content); } else { reject(&quot;Rename file failed&quot;); } document.documentElement.removeEventListener(&quot;tsMessage&quot;, eventListener); } } document.documentElement.addEventListener(&quot;tsMessage&quot;, eventListener); }); } /** * Rename a directory * @name renameDirectoryPromise * @method * @memberof IOAPI.FirefoxAddon * @param {string} path - the full path of the directory which will be renamed * @returns {Promise.&lt;Success, Error&gt;} */ function renameDirectoryPromise(path) { return new Promise(function(res, rej) { TSCORE.showAlertDialog($.i18n.t(&quot;ns.common:functionalityNotImplemented&quot;)); res(true); }); } /** * Delete a specified file * @name deleteFilePromise * @method * @memberof IOAPI.FirefoxAddon * @param {string} path - the full path of the file which will be deleted * @returns {Promise.&lt;Success, Error&gt;} */ function deleteFilePromise(path) { return new Promise(function(resolve, reject) { console.log(&quot;Deleting: &quot; + path); var event = document.createEvent('CustomEvent'); event.initCustomEvent(&quot;addon-message&quot;, true, true, { &quot;detail&quot;: { &quot;command&quot;: &quot;delete&quot;, &quot;path&quot;: path } }); document.documentElement.dispatchEvent(event); function eventListener(event) { var message = event.detail; if (message.command === &quot;delete&quot;) { if (message.success) { resolve(message.content); } else { reject(&quot;Delete file failed&quot;); } document.documentElement.removeEventListener(&quot;tsMessage&quot;, eventListener); } } document.documentElement.addEventListener(&quot;tsMessage&quot;, eventListener); }); } /** * Delete a specified directory, the directory should be empty, if the trash can functionality is not enabled * @name deleteDirectoryPromise * @method * @memberof IOAPI.FirefoxAddon * @param {string} path - the full path of the directory which will be deleted * @returns {Promise.&lt;Success, Error&gt;} */ function deleteDirectoryPromise(path) { return new Promise(function(res, rej) { TSCORE.showAlertDialog($.i18n.t(&quot;ns.common:functionalityNotImplemented&quot;)); res(true); }); } /** * Selects a directory with the help of a directory chooser * @name selectDirectory * @method * @memberof IOAPI.FirefoxAddon */ function selectDirectory() { console.log(&quot;Selecting directory...&quot;); var event = document.createEvent('CustomEvent'); event.initCustomEvent(&quot;addon-message&quot;, true, true, { &quot;detail&quot;: { &quot;command&quot;: &quot;selectDirectory&quot; } }); document.documentElement.dispatchEvent(event); } /** * Selects a file with the help of a file chooser * @name selectFile * @method * @memberof IOAPI.FirefoxAddon */ function selectFile() { console.log(&quot;Selecting file...&quot;); var event = document.createEvent('CustomEvent'); event.initCustomEvent(&quot;addon-message&quot;, true, true, { &quot;detail&quot;: { &quot;command&quot;: &quot;selectFile&quot; } }); document.documentElement.dispatchEvent(event); } /** * Opens a directory in the operating system's default file manager * @name openDirectory * @method * @memberof IOAPI.FirefoxAddon * @param {string} dirPath - the full path of the directory which will be opened */ function openDirectory(dirPath) { console.log(&quot;Opening directory: &quot; + dirPath); var event = document.createEvent('CustomEvent'); event.initCustomEvent(&quot;addon-message&quot;, true, true, { &quot;detail&quot;: { &quot;command&quot;: &quot;openDirectory&quot;, &quot;path&quot;: dirPath } }); document.documentElement.dispatchEvent(event); } /** * Opens a file with the operating system's default program for the type of the file * @name openFile * @method * @memberof IOAPI.FirefoxAddon * @param {string} filePath - the full path of the file which will be opened */ function openFile(filePath) { // TODO implement openFile for firefox console.log(&quot;Open file functionality not implemented in Firefox yet!&quot;); TSCORE.showAlertDialog($.i18n.t(&quot;ns.dialogs:openFileNativelyAlert&quot;)); } // mozilla specific exports.saveSettings = saveSettings; exports.loadSettings = loadSettings; // Platform API exports.focusWindow = focusWindow; exports.checkNewVersion = checkNewVersion; exports.createDirectoryTree = createDirectoryTree; exports.listDirectoryPromise = listDirectoryPromise; exports.getPropertiesPromise = getPropertiesPromise; exports.loadTextFilePromise = loadTextFilePromise; exports.getFileContentPromise = getFileContentPromise; exports.saveFilePromise = saveFilePromise; exports.saveTextFilePromise = saveFilePromise; exports.saveBinaryFilePromise = saveBinaryFilePromise; exports.createDirectoryPromise = createDirectoryPromise; exports.copyFilePromise = copyFilePromise; exports.renameFilePromise = renameFilePromise; exports.renameDirectoryPromise = renameDirectoryPromise; exports.deleteFilePromise = deleteFilePromise; exports.deleteDirectoryPromise = deleteDirectoryPromise; exports.selectDirectory = selectDirectory; exports.selectFile = selectFile; exports.openDirectory = openDirectory; exports.openFile = openFile; }); Ã— Search results Close "},"node-webkit_node-webkit.api.js.html":{"id":"node-webkit_node-webkit.api.js.html","title":"Source: node-webkit/node-webkit.api.js","body":" TagSpaces API Classes IOAPIIOAPI.ChromeExtensionIOAPI.CordovaIOAPI.FirefoxAddonIOAPI.NWJSIOAPI.WebDAVTSCORE Source: node-webkit/node-webkit.api.js /* Copyright (c) 2012-2016 The TagSpaces Authors. All rights reserved. * Use of this source code is governed by a AGPL3 license that * can be found in the LICENSE file. */ var fs = require('fs-extra'); // jshint ignore:line var pathUtils = require('path'); // jshint ignore:line var gui = require('nw.gui'); // jshint ignore:line var trash = require('trash'); // jshint ignore:line /** * A implementation of the IOAPI for the nw.js platform * @class NWJS * @memberof IOAPI */ define(function(require, exports, module) { &quot;use strict&quot;; console.log(&quot;Loading ioapi.node.js..&quot;); var TSCORE = require(&quot;tscore&quot;); var TSPOSTIO = require(&quot;tspostioapi&quot;); var fsWatcher; var win = gui.Window.get(); var showMainWindow = function() { win.show(); }; win.on('close', function() { if (TSCORE.FileOpener.isFileChanged()) { if (confirm($.i18n.t(&quot;ns.common:confirmApplicationClose&quot;))) { win.close(true); } } else { win.close(true); } }); var rootMenu = new gui.Menu({type: 'menubar'}); var aboutMenu = new gui.Menu(); var viewMenu = new gui.Menu(); var menuInitialuzed = false; process.on(&quot;uncaughtException&quot;, function(err) { //var msg = ' Information | Description \\n' + // '-------------|-----------------------------\\n' + // ' Date | '+ new Date +'\\n' + // ' Type | UncaughtException \\n' + // ' Stack | '+ err.stack +'\\n\\n'; //fs.appendFile(errorLogFile, '---uncaughtException---\\n' + msg); }); // Experimental functionality function watchDirecotory(dirPath, listener) { if (fsWatcher) { fsWatcher.close(); } fsWatcher = fs.watch(dirPath, {persistent: true, recursive: false}, listener); } function handleTray() { // TODO disable in Ubuntu until node-webkit issue in unity fixed // Reference to window and tray var win = gui.Window.get(); var tray; // Get the minimize event win.on('minimize', function() { // Hide window this.hide(); // Show tray tray = new gui.Tray({ title: 'Tray', icon: 'icon128.png' }); // Show window and remove tray when clicked tray.on('click', function() { win.show(); this.remove(); tray = null; }); }); } function handleStartParameters() { //Windows &quot;C:\\Users\\na\\Desktop\\TagSpaces\\tagspaces.exe&quot; --original-process-start-time=13043601900594583 &quot;G:\\data\\assets\\icon16.png&quot; //Linux /opt/tagspaces/tagspaces /home/na/Dropbox/TagSpaces/README[README].md //OSX /home/na/Dropbox/TagSpaces/README[README].md //gui.App.on('open', function(cmdline) { // console.log('Command line arguments on open: ' + cmdline); // TSCORE.FileOpener.openFile(cmdArguments); //}); var cmdArguments = gui.App.argv; if (cmdArguments &amp;&amp; cmdArguments.length &gt; 0) { console.log(&quot;CMD Arguments: &quot; + cmdArguments[0] + &quot; Process running in &quot; + process.cwd()); var dataPathIndex; cmdArguments.forEach(function(part, index) { if (part.indexOf(&quot;--data-path&quot;) === 0) { dataPathIndex = index; } }); if (dataPathIndex &gt;= 0 &amp;&amp; cmdArguments.length &gt;= dataPathIndex + 1) { cmdArguments.splice(dataPathIndex, 2); } console.log(&quot;CMD Arguments cleaned: &quot; + cmdArguments); var filePath = &quot;&quot; + cmdArguments; if (filePath.length &gt; 1) { var dirPath = TSCORE.TagUtils.extractContainingDirectoryPath(filePath); TSCORE.FileOpener.openFileOnStartup(filePath); } } } function initMainMenu() { if (isOSX) { rootMenu.createMacBuiltin(&quot;TagSpaces&quot;); } if (TSCORE.Config.getShowMainMenu() &amp;&amp; !menuInitialuzed) { aboutMenu.append(new gui.MenuItem({ type: 'normal', label: $.i18n.t(&quot;ns.common:aboutTagSpaces&quot;), click: function() { TSCORE.UI.showAboutDialog(); } })); viewMenu.append(new gui.MenuItem({ type: 'normal', label: $.i18n.t(&quot;ns.common:showTagLibraryTooltip&quot;) + &quot; (&quot; + TSCORE.Config.getShowTagLibraryKeyBinding() + &quot;)&quot;, click: function() { TSCORE.UI.showTagsPanel(); } })); viewMenu.append(new gui.MenuItem({ type: 'normal', label: $.i18n.t(&quot;ns.common:showLocationNavigatorTooltip&quot;) + &quot; (&quot; + TSCORE.Config.getShowFolderNavigatorBinding() + &quot;)&quot;, click: function() { TSCORE.UI.showLocationsPanel(); } })); viewMenu.append(new gui.MenuItem({ type: 'separator' })); viewMenu.append(new gui.MenuItem({ type: 'normal', label: $.i18n.t(&quot;ns.common:toggleFullScreen&quot;) + &quot; (&quot; + TSCORE.Config.getToggleFullScreenKeyBinding().toUpperCase() + &quot;)&quot;, click: function() { win.toggleFullscreen(); } })); viewMenu.append(new gui.MenuItem({ type: 'normal', label: $.i18n.t(&quot;ns.common:showDevTools&quot;) + &quot; (&quot; + TSCORE.Config.getOpenDevToolsScreenKeyBinding().toUpperCase() + &quot;)&quot;, click: function() { win.showDevTools(); } })); viewMenu.append(new gui.MenuItem({ type: 'separator' })); viewMenu.append(new gui.MenuItem({ type: 'normal', label: $.i18n.t(&quot;ns.common:settings&quot;), click: function() { TSCORE.UI.showOptionsDialog(); } })); rootMenu.append(new gui.MenuItem({ type: 'normal', label: $.i18n.t(&quot;ns.common:view&quot;), submenu: viewMenu })); rootMenu.append(new gui.MenuItem({ type: 'normal', label: $.i18n.t(&quot;ns.common:help&quot;), submenu: aboutMenu })); win.menu = rootMenu; menuInitialuzed = true; } else { if (isOSX) { win.menu = rootMenu; } } } // Brings the TagSpaces window on top of the windows function focusWindow() { gui.Window.get().focus(); } // IOAPI /** * Checks if new version is available * @name checkNewVersion * @method * @memberof IOAPI.NWJS */ function checkNewVersion() { console.log(&quot;Checking for new version...&quot;); var cVer = TSCORE.Config.DefaultSettings.appVersion + &quot;.&quot; + TSCORE.Config.DefaultSettings.appBuild; $.ajax({ url: 'http://tagspaces.org/releases/version.json?nVer=' + cVer, type: 'GET' }) .done(function(data) { TSPOSTIO.checkNewVersion(data); }) .fail(function(data) { console.log(&quot;AJAX failed &quot; + data); }); } /** * Creates recursively a tree structure for a given directory path * @name createDirectoryTree * @method * @memberof IOAPI.NWJS * @param {string} dirPath - the full path of the directory for which the tree will be generated */ function createDirectoryTree(dirPath) { console.log(&quot;Creating directory index for: &quot; + dirPath); TSCORE.showWaitingDialog($.i18n.t(&quot;ns.common:waitDialogDiectoryIndexing&quot;)); var generateDirectoryTree = function(dirPath) { try { var tree = {}; var dstats = fs.lstatSync(dirPath); tree.name = pathUtils.basename(dirPath); tree.isFile = false; tree.lmdt = dstats.mtime; tree.path = dirPath; tree.children = []; var dirList = fs.readdirSync(dirPath); for (var i = 0; i &lt; dirList.length; i++) { var path = dirPath + TSCORE.dirSeparator + dirList[i]; var stats = fs.lstatSync(path); if (stats.isFile()) { tree.children.push({ &quot;name&quot;: pathUtils.basename(path), &quot;isFile&quot;: true, &quot;size&quot;: stats.size, &quot;lmdt&quot;: stats.mtime, &quot;path&quot;: path }); } else { tree.children.push(generateDirectoryTree(path)); } } return tree; } catch (ex) { TSCORE.hideLoadingAnimation(); console.error(&quot;Generating tree for &quot; + dirPath + &quot; failed &quot; + ex); } }; var directoyTree = generateDirectoryTree(dirPath); //console.log(JSON.stringify(directoyTree)); TSPOSTIO.createDirectoryTree(directoyTree); } /** * Creates a list with containing the files and the sub directories of a given directory * @name listDirectoryPromiseAsync * @method * @memberof IOAPI.NWJS * @param {string} path - the directory path for which the list will be created * @returns {Promise.&lt;Success, Error&gt;} */ function listDirectoryPromiseAsync(path) { console.time(&quot;listDirectoryPromise&quot;); return new Promise(function(resolve, reject) { var statEntriesPromises = []; fs.readdir(path, function(error, entries) { if (error) { console.log(&quot;Error listing directory &quot; + path); resolve([]); // returning results even if any promise fails } if (entries) { entries.forEach(function(entry) { statEntriesPromises.push(getPropertiesPromise(path + TSCORE.dirSeparator + entry)); }); Promise.all(statEntriesPromises).then(function(enhancedEntries) { console.timeEnd(&quot;listDirectoryPromise&quot;); resolve(enhancedEntries); }, function(err) { resolve([]); // returning results even if any promise fails }); } }); }); } /** * Creates a list with containing the files and the sub directories of a given directory * @name listDirectoryPromise * @method * @memberof IOAPI.NWJS * @param {string} path - the directory path which is listed * @param {boolean} lite - if true the path to a file thumbnails will be not included in the results * This will increase the performance of the function. * @returns {Promise.&lt;Success, Error&gt;} */ function listDirectoryPromise(path, lite) { console.time(&quot;listDirectoryPromise&quot;); return new Promise(function(resolve, reject) { var enhancedEntries = []; var entryPath; var thumbPath; var stats; var thumbStats; var eentry; var metaMetaFolder = TSCORE.metaFolder + TSCORE.dirSeparator + TSCORE.metaFolder; fs.readdir(path, function(error, entries) { if (error) { console.log(&quot;Error listing directory &quot; + path); resolve(enhancedEntries); // returning results even if any promise fails } if (entries) { entries.forEach(function(entry) { entryPath = path + TSCORE.dirSeparator + entry; thumbPath = path + TSCORE.dirSeparator + TSCORE.metaFolder + TSCORE.dirSeparator + entry + TSCORE.thumbFileExt; eentry = {}; eentry.name = entry; eentry.path = entryPath; try { stats = fs.statSync(entryPath); eentry.isFile = stats.isFile(); eentry.size = stats.size; eentry.lmdt = stats.mtime.getTime(); if (!lite &amp;&amp; eentry.isFile &amp;&amp; thumbPath.indexOf(metaMetaFolder) &lt; 0) { // prevent checking in .ts/.ts folder try { thumbStats = fs.statSync(thumbPath); if (thumbStats.isFile) { eentry.thumbPath = thumbPath; } } catch (e) { console.log(&quot;Can not find thumbnail for file: &quot; + thumbPath); } // TODO Extract the name of the sidecar json file } } catch (e) { console.warn(&quot;Can not load properties for: &quot; + entryPath); } enhancedEntries.push(eentry); }); console.timeEnd(&quot;listDirectoryPromise&quot;); resolve(enhancedEntries); } }); }); } /** * Finds out the properties of a file or directory such last modification date or file size * @name getPropertiesPromise * @method * @memberof IOAPI.NWJS * @param {string} path - full path to the file or the directory, which will be analysed * @returns {Promise.&lt;Success, Error&gt;} */ function getPropertiesPromise(path) { /** * stats for file: * &quot;dev&quot;:41, * &quot;mode&quot;:33204, * &quot;nlink&quot;:1, * &quot;uid&quot;:1000, * &quot;gid&quot;:1000, * &quot;rdev&quot;:0, * &quot;blksize&quot;:4096, * &quot;ino&quot;:2634172, * &quot;size&quot;:230, * &quot;blocks&quot;:24, * &quot;atime&quot;:&quot;2015-11-24T09:56:41.932Z&quot;, * &quot;mtime&quot;:&quot;2015-11-23T14:29:29.689Z&quot;, * &quot;ctime&quot;:&quot;2015-11-23T14:29:29.689Z&quot;, * &quot;birthtime&quot;:&quot;2015-11-23T14:29:29.689Z&quot;, * &quot;isFile&quot;:true, * &quot;path&quot;:&quot;/home/somefile.txt&quot; */ return new Promise(function(resolve, reject) { fs.lstat(path, function(err, stats) { if (err) { resolve(false); } if (stats) { var entry = {}; entry.name = path.substring(path.lastIndexOf(TSCORE.dirSeparator) + 1, path.length); entry.isFile = stats.isFile(); entry.size = stats.size; entry.lmdt = stats.mtime; entry.path = path; resolve(entry); } }); }); } /** * Creates a directory * @name createDirectoryPromise * @method * @memberof IOAPI.NWJS * @param {string} dirPath - the full path of the folder which will be created * @returns {Promise.&lt;Success, Error&gt;} */ function createDirectoryPromise(dirPath) { return new Promise(function(resolve, reject) { fs.mkdir(dirPath, function(error) { if (error) { reject(&quot;Error creating folder: &quot; + dirPath); } resolve(); }); }); } /** * Copies a given file to a specified location * @name copyFilePromise * @method * @memberof IOAPI.NWJS * @param {string} sourceFilePath - the full path of a file which will be copied * @param {string} targetFilePath - the full path destination of the copied file * @returns {Promise.&lt;Success, Error&gt;} */ function copyFilePromise(sourceFilePath, targetFilePath) { return new Promise(function(resolve, reject) { getPropertiesPromise(sourceFilePath).then(function(entry) { if (!entry.isFile) { reject($.i18n.t(&quot;ns.common:fileIsDirectory&quot;, {fileName:sourceFilePath})); } else { getPropertiesPromise(targetFilePath).then(function(entry2) { if (entry2) { reject($.i18n.t(&quot;ns.common:fileExists&quot;, {fileName:targetFilePath})); } else { var rd = fs.createReadStream(sourceFilePath); rd.on(&quot;error&quot;, function(err) { reject($.i18n.t(&quot;ns.common:fileCopyFailed&quot;, {fileName:sourceFilePath})); }); var wr = fs.createWriteStream(targetFilePath); wr.on(&quot;error&quot;, function(err) { reject($.i18n.t(&quot;ns.common:fileCopyFailed&quot;, {fileName:sourceFilePath})); }); wr.on(&quot;close&quot;, function(ex) { resolve(); }); rd.pipe(wr); } }, function(err) { reject(err); }); } }, function(err) { reject(err); }); }); } /** * Renames a given file * @name renameFilePromise * @method * @memberof IOAPI.NWJS * @param {string} filePath - the full path of the file which will be renamed * @param {string} newFilePath - the desired full path after the file rename * @returns {Promise.&lt;Success, Error&gt;} */ function renameFilePromise(filePath, newFilePath) { console.log(&quot;Renaming file: &quot; + filePath + &quot; to &quot; + newFilePath); return new Promise(function(resolve, reject) { if (filePath === newFilePath) { reject($.i18n.t(&quot;ns.common:fileTheSame&quot;), $.i18n.t(&quot;ns.common:fileNotMoved&quot;)); } if (fs.lstatSync(filePath).isDirectory()) { reject($.i18n.t(&quot;ns.common:fileIsDirectory&quot;, {fileName:filePath})); } if (fs.existsSync(newFilePath)) { reject($.i18n.t(&quot;ns.common:fileExists&quot;, {fileName:newFilePath}), $.i18n.t(&quot;ns.common:fileRenameFailed&quot;)); } fs.move(filePath, newFilePath, function(error) { if (error) { reject(&quot;Renaming: &quot; + filePath + &quot; failed.&quot;); } resolve([filePath, newFilePath]); }); }); } /** * Rename a directory * @name renameDirectoryPromise * @method * @memberof IOAPI.NWJS * @param {string} dirPath - the full path of the directory which will be renamed * @param {string} newDirName - the desired full path after the directory rename * @returns {Promise.&lt;Success, Error&gt;} */ function renameDirectoryPromise(dirPath, newDirName) { var newDirPath = TSCORE.TagUtils.extractParentDirectoryPath(dirPath) + TSCORE.dirSeparator + newDirName; console.log(&quot;Renaming dir: &quot; + dirPath + &quot; to &quot; + newDirPath); return new Promise(function(resolve, reject) { if (dirPath === newDirPath) { reject($.i18n.t(&quot;ns.common:directoryTheSame&quot;), $.i18n.t(&quot;ns.common:directoryNotMoved&quot;)); } if (fs.existsSync(newDirPath)) { reject($.i18n.t(&quot;ns.common:directoryExists&quot;, {dirName:newDirPath}), $.i18n.t(&quot;ns.common:directoryRenameFailed&quot;)); } var dirStatus = fs.lstatSync(dirPath); if (dirStatus.isDirectory) { fs.rename(dirPath, newDirPath, function(error) { if (error) { console.error(&quot;Renaming directory failed &quot; + error); reject(&quot;Renaming &quot; + dirPath + &quot; failed.&quot;); } resolve(newDirPath); }); } else { reject($.i18n.t(&quot;ns.common:pathIsNotDirectory&quot;, {dirName:dirPath}), $.i18n.t(&quot;ns.common:directoryRenameFailed&quot;)); } }); } /** * Load the content of a text file * @name loadTextFilePromise * @method * @memberof IOAPI.NWJS * @param {string} filePath - the full path of the file which will be loaded * @param {boolean} isPreview - loads only begin of a file (first 10000 bytes) usefull for previewing of the file * @returns {Promise.&lt;Success, Error&gt;} */ function loadTextFilePromise(filePath, isPreview) { console.log(&quot;Loading file: &quot; + filePath); return new Promise(function(resolve, reject) { if (isPreview) { var stream = fs.createReadStream(filePath, { start: 0, end: 10000 }); stream.on('error', function(err) { reject(err); }); stream.on('data', function(content) { //console.log(&quot;Stream: &quot; + content); resolve(content); }); } else { fs.readFile(filePath, 'utf8', function(error, content) { if (error) { reject(error); } else { resolve(content); } }); } }); } /** * Gets the content of file, useful for binary files * @name getFileContentPromise * @method * @memberof IOAPI.NWJS * @param {string} fullPath - the full path of the file which will be loaded * @param {string} type - the type of the XHR response, defaul is *arraybuffer* * @returns {Promise.&lt;Success, Error&gt;} */ function getFileContentPromise(fullPath, type) { return new Promise(function(resolve, reject) { var fileURL = fullPath; if (fileURL.indexOf(&quot;file://&quot;) === -1) { fileURL = &quot;file://&quot; + fileURL; } var xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;, fileURL, true); xhr.responseType = type || &quot;arraybuffer&quot;; xhr.onerror = reject; xhr.onload = function() { var response = xhr.response || xhr.responseText; if (response) { resolve(response); } else { reject(&quot;getFileContentPromise error&quot;); } }; xhr.send(); }); } /** * Persists a given content(binary supported) to a specified filepath * @name saveFilePromise * @method * @memberof IOAPI.NWJS * @param {string} filePath - the full path of the file which should be saved * @param {string} content - content that will be saved * @param {boolean} overwrite - if true existing file path will be overwritten * @returns {Promise.&lt;Success, Error&gt;} */ function saveFilePromise(filePath, content, overwrite) { return new Promise(function(resolve, reject) { function saveFile(filePath, content, isNewFile) { fs.writeFile(filePath, content, 'utf8', function(error) { if (error) { reject(error); } resolve(isNewFile); }); } getPropertiesPromise(filePath).then(function(entry) { overwrite = overwrite || true; if (entry &amp;&amp; entry.isFile &amp;&amp; overwrite) { saveFile(filePath, content, false); } else { saveFile(filePath, content, true); } }, function(err) { saveFile(filePath, content, true); }); }); } /** * Persists a given text content to a specified filepath * @name saveTextFilePromise * @method * @memberof IOAPI.NWJS * @param {string} filePath - the full path of the file which will be saved * @param {string} content - content that will be saved * @param {string} overwrite - if true existing file path will be overwritten * @returns {Promise.&lt;Success, Error&gt;} */ function saveTextFilePromise(filePath, content, overwrite) { console.log(&quot;Saving file: &quot; + filePath); // Handling the UTF8 support for text files var UTF8_BOM = &quot;\\ufeff&quot;; if (content.indexOf(UTF8_BOM) === 0) { console.log(&quot;Content beging with a UTF8 bom&quot;); } else { content = UTF8_BOM + content; } return saveFilePromise(filePath, content, overwrite); } /** * Persists a given binary content to a specified filepath * @name saveBinaryFilePromise * @method * @memberof IOAPI.NWJS * @param {string} filePath - the full path of the file which will be saved * @param {string} content - content that will be saved * @param {string} overwrite - if true existing file path will be overwritten * @returns {Promise.&lt;Success, Error&gt;} */ function saveBinaryFilePromise(filePath, content, overwrite) { console.log(&quot;Saving binary file: &quot; + filePath); var buff = TSCORE.Utils.arrayBufferToBuffer(content); return saveFilePromise(filePath, buff, overwrite); } /** * Delete a specified file * @name deleteFilePromise * @method * @memberof IOAPI.NWJS * @param {string} path - the full path of the file which will be deleted * @returns {Promise.&lt;Success, Error&gt;} */ function deleteFilePromise(path) { //TODO Handling the trash can case if (TSCORE.PRO &amp;&amp; TSCORE.Config.getUseTrashCan()) { return new Promise(function(resolve, reject) { trash([path]).then(function() { resolve(path); }, function(err) { reject(err); }); }); } else { return new Promise(function(resolve, reject) { fs.unlink(path, function(error) { if (error) { reject(error); } else { resolve(path); } }); }); } } /** * Delete a specified directory, the directory should be empty, if the trash can functionality is not enabled * @name deleteDirectoryPromise * @method * @memberof IOAPI.NWJS * @param {string} path - the full path of the directory which will be deleted * @returns {Promise.&lt;Success, Error&gt;} */ function deleteDirectoryPromise(path) { if (TSCORE.PRO &amp;&amp; TSCORE.Config.getUseTrashCan()) { return trash([path]); } else { return new Promise(function(resolve, reject) { fs.rmdir(path, function(error) { if (error) { reject(error); } else { resolve(path); } }); }); } } /** * Selects a directory with the help of a directory chooser * @name selectDirectory * @method * @memberof IOAPI.NWJS */ function selectDirectory() { if (document.getElementById('folderDialogNodeWebkit') === null) { $(&quot;body&quot;).append('&lt;input style=&quot;display:none;&quot; id=&quot;folderDialogNodeWebkit&quot; type=&quot;file&quot; nwdirectory /&gt;'); } var chooser = $('#folderDialogNodeWebkit'); chooser.on(&quot;change&quot;, function() { TSPOSTIO.selectDirectory($(this).val()); $(this).off(&quot;change&quot;); $(this).val(&quot;&quot;); }); chooser.trigger('click'); } /** * Selects a file with the help of a file chooser * @name selectFile * @method * @memberof IOAPI.NWJS */ function selectFile() { if (document.getElementById('fileDialog') === null) { $(&quot;#folderLocation&quot;).after('&lt;input style=&quot;display:none;&quot; id=&quot;fileDialog&quot; type=&quot;file&quot; /&gt;'); } var chooser = $('#fileDialog'); chooser.change(function() { console.log(&quot;File selected: &quot; + $(this).val()); }); chooser.trigger('click'); } /** * Opens a directory in the operating system's default file manager * @name openDirectory * @method * @memberof IOAPI.NWJS * @param {string} dirPath - the full path of the directory which will be opened */ function openDirectory(dirPath) { // opens directory gui.Shell.openItem(dirPath); } /** * Opens a file with the operating system's default program for the type of the file * @name openFile * @method * @memberof IOAPI.NWJS * @param {string} filePath - the full path of the file which will be opened */ function openFile(filePath) { // opens file with the native program gui.Shell.openItem(filePath); } // Platform specific calls exports.initMainMenu = initMainMenu; exports.showMainWindow = showMainWindow; // Platform API exports.handleStartParameters = handleStartParameters; exports.focusWindow = focusWindow; exports.checkNewVersion = checkNewVersion; exports.createDirectoryTree = createDirectoryTree; exports.listDirectoryPromise = listDirectoryPromise; exports.getPropertiesPromise = getPropertiesPromise; exports.loadTextFilePromise = loadTextFilePromise; exports.getFileContentPromise = getFileContentPromise; exports.saveFilePromise = saveFilePromise; exports.saveTextFilePromise = saveTextFilePromise; exports.saveBinaryFilePromise = saveBinaryFilePromise; exports.createDirectoryPromise = createDirectoryPromise; exports.copyFilePromise = copyFilePromise; exports.renameFilePromise = renameFilePromise; exports.renameDirectoryPromise = renameDirectoryPromise; exports.deleteFilePromise = deleteFilePromise; exports.deleteDirectoryPromise = deleteDirectoryPromise; exports.selectDirectory = selectDirectory; exports.selectFile = selectFile; exports.openDirectory = openDirectory; exports.openFile = openFile; }); Ã— Search results Close "},"web_web.api.js.html":{"id":"web_web.api.js.html","title":"Source: web/web.api.js","body":" TagSpaces API Classes IOAPIIOAPI.ChromeExtensionIOAPI.CordovaIOAPI.FirefoxAddonIOAPI.NWJSIOAPI.WebDAVTSCORE Source: web/web.api.js /* Copyright (c) 2012-2013 The TagSpaces Authors. All rights reserved. * Use of this source code is governed by a AGPL3 license that * can be found in the LICENSE file. */ /** * A implementation of the IOAPI for the Chrome/Chromium extensions platform * @class WebDAV * @memberof IOAPI */ define(function(require, exports, module) { &quot;use strict&quot;; // Activating browser specific exports modul console.log(&quot;Loading web.js..&quot;); var TSCORE = require(&quot;tscore&quot;); var TSPOSTIO = require(&quot;tspostioapi&quot;); require(&quot;webdavlib/webdavlib&quot;); var davClient; //exact copy of getAjax with timeout added nl.sara.webdav.Client.prototype.getAjax = function(method, url, callback, headers) { var /** @type XMLHttpRequest */ ajax = (((typeof Components !== 'undefined') &amp;&amp; (typeof Components.classes !== 'undefined')) ? Components.classes[&quot;@mozilla.org/xmlextras/xmlhttprequest;1&quot;].createInstance(Components.interfaces.nsIXMLHttpRequest) : new XMLHttpRequest()); if (this._username !== null) { ajax.open(method, url, true, this._username, this._password); } else { ajax.open(method, url, true); } ajax.onreadystatechange = function() { nl.sara.webdav.Client.ajaxHandler(ajax, callback); }; ajax.ontimeout = function() { ajax.readyState = 4; ajax.ajax.status = -1; nl.sara.webdav.Client.ajaxHandler(ajax, callback); }; if (headers === undefined) { headers = {}; } for (var header in this._headers) { if (headers[header] === undefined) { ajax.setRequestHeader(header, this._headers[header]); } } for (var header in headers) { ajax.setRequestHeader(header, headers[header]); } return ajax; }; function connectDav() { console.log(&quot;Connecting webdav...&quot;); var useHTTPS = false; if (location.href.indexOf(&quot;https&quot;) === 0) { useHTTPS = true; } davClient = new nl.sara.webdav.Client(location.hostname, useHTTPS, location.port); } //window.setTimeout( connectDav(); //, 2000); function getNameForPath(path) { if (path.lastIndexOf(&quot;/&quot;) == path.length - 1) { path = path.substring(0, path.lastIndexOf(&quot;/&quot;)); } var encodedName = path.substring(path.lastIndexOf(&quot;/&quot;) + 1, path.length); return decodeURI(encodedName); } function isDirectory(path) { // TODO find a better solution return path.lastIndexOf(&quot;/&quot;) == path.length - 1; } function checkStatusCode(code) { var status = parseInt(code / 100); if (status === 2) { return true; } return false; } function handleStartParameters() { var filePath = TSCORE.Utils.getURLParameter(&quot;open&quot;); if (filePath &amp;&amp; (filePath.length &gt; 0)) { filePath = decodeURIComponent(filePath); console.log(&quot;Opening file in browser: &quot; + filePath); TSCORE.FileOpener.openFileOnStartup(filePath); } } function focusWindow() { // Bring the TagSpaces window on top of the windows window.focus(); } /** * Checks if new version is available * @name checkNewVersion * @method * @memberof IOAPI.web */ function checkNewVersion() { // console.log(&quot;Checking for new version not relevant fot the webdav version&quot;); } /** * Creates recursively a tree structure for a given directory path * @name createDirectoryTree * @method * @memberof IOAPI.web * @param {string} dirPath - the full path of the directory for which the tree will be generated */ function createDirectoryTree(dirPath) { console.log(&quot;Creating directory index for: &quot; + dirPath); TSCORE.showLoadingAnimation(); var directoyTree = []; //console.log(JSON.stringify(directoyTree)); TSPOSTIO.createDirectoryTree(directoyTree); } /** * Creates a list with containing the files and the sub directories of a given directory * @name listDirectoryPromise * @method * @memberof IOAPI.web * @param {string} dirPath - the directory path which is listed * @returns {Promise.&lt;Success, Error&gt;} */ function listDirectoryPromise(dirPath) { dirPath = dirPath.split(&quot;//&quot;).join(&quot;/&quot;); console.log(&quot;Listing directory: &quot; + dirPath); return new Promise(function(resolve, reject) { var anotatedDirList; var davSuccess = function(status, data) { console.log(&quot;Dirlist Status: &quot; + status); if (!checkStatusCode(status)) { console.warn(&quot;Listing directory &quot; + dirPath + &quot; failed &quot; + status); reject(&quot;Listing directory &quot; + dirPath + &quot; failed &quot; + status); } var dirList = data._responses; var fileName, isDir, filesize, lmdt, path; anotatedDirList = []; for (var entry in dirList) { path = dirList[entry].href; if (dirPath.toLowerCase() === path.toLowerCase()) { console.log(&quot;Skipping current folder&quot;); } else { isDir = false; filesize = undefined; lmdt = undefined; //console.log(dirList[entry]._namespaces[&quot;DAV:&quot;]); if (typeof dirList[entry]._namespaces[&quot;DAV:&quot;].getcontentlength === 'undefined' || dirList[entry]._namespaces[&quot;DAV:&quot;].getcontentlength._xmlvalue.length === 0 ) { isDir = true; } else { filesize = dirList[entry]._namespaces[&quot;DAV:&quot;].getcontentlength._xmlvalue[0].data; lmdt = data._responses[entry]._namespaces[&quot;DAV:&quot;].getlastmodified._xmlvalue[0].data; } fileName = getNameForPath(path); anotatedDirList.push({ &quot;name&quot;: fileName, &quot;isFile&quot;: !isDir, &quot;size&quot;: filesize, &quot;lmdt&quot;: lmdt, &quot;path&quot;: decodeURI(path) }); } } resolve(anotatedDirList); }; if (dirPath.substring(dirPath.length - 1) !== &quot;/&quot;) { dirPath = dirPath + &quot;/&quot;; } dirPath = encodeURI(dirPath); davClient.propfind( dirPath, davSuccess, 1 //1 , davClient.INFINITY ); }); } /** * Finds out the properties of a file or directory such last modification date or file size * @name getPropertiesPromise * @method * @memberof IOAPI.web * @param {string} filePath - full path to the file or the directory, which will be analysed * @returns {Promise.&lt;Success, Error&gt;} */ function getPropertiesPromise(filePath) { return new Promise(function(resolve, reject) { davClient.propfind(encodeURI(filePath), function(status, data) { console.log(&quot;Properties Status / Content: &quot; + status + &quot; / &quot; + JSON.stringify(data._responses)); var fileProperties = {}; if (checkStatusCode(status)) { for (var entry in data._responses) { fileProperties.path = filePath; fileProperties.size = data._responses[entry]._namespaces[&quot;DAV:&quot;].getcontentlength; fileProperties.lmdt = data._responses[entry]._namespaces[&quot;DAV:&quot;].getlastmodified._xmlvalue[0].data; } resolve(fileProperties); } else { reject(&quot;getFileProperties &quot; + filePath + &quot; failed &quot; + status); } }, 1); }); } /** * Load the content of a text file * @name loadTextFilePromise * @method * @memberof IOAPI.web * @param {string} filePath - the full path of the file which will be loaded * @returns {Promise.&lt;Success, Error&gt;} */ function loadTextFilePromise(filePath) { // return getFileContentPromise(filePath, &quot;text&quot;); } /** * Gets the content of file, useful for binary files * @name getFileContentPromise * @method * @memberof IOAPI.web * @param {string} filePath - the full path of the file which will be loaded * @param {string} type - the type of the XHR response, defaul is *arraybuffer* * @returns {Promise.&lt;Success, Error&gt;} */ function getFileContentPromise(filePath, type) { console.log(&quot;getFileContent file: &quot; + filePath); return new Promise(function(resolve, reject) { var ajax = davClient.getAjax(&quot;GET&quot;, filePath); ajax.onreadystatechange = null; ajax.responseType = type || &quot;arraybuffer&quot;; ajax.onerror = reject; ajax.onload = function() { var response = ajax.response || ajax.responseText; if (checkStatusCode(ajax.status)) { resolve(response); } else { reject(&quot;getFileContentPromise ajax error&quot;); } }; ajax.send(); }); } /** * Persists a given content(binary supported) to a specified filepath * @name saveFilePromise * @method * @memberof IOAPI.web * @param {string} filePath - the full path of the file which should be saved * @param {string} content - content that will be saved * @param {boolean} overWrite - if true existing file path will be overwritten * @param {boolean} mode - //TODO * @returns {Promise.&lt;Success, Error&gt;} */ function saveFilePromise(filePath, content, overWrite, mode) { return new Promise(function(resolve, reject) { var isNewFile = false; davClient.propfind(encodeURI(filePath), function(status, data) { console.log(&quot;Check file exists: Status / Content: &quot; + status + &quot; / &quot; + data); if (parseInt(status) === 404) { isNewFile = true; } if (isNewFile || overWrite === true || mode === &quot;text&quot;) { davClient.put( encodeURI(filePath), function(status, data, headers) { console.log(&quot;Creating File Status/Content/Headers: &quot; + status + &quot; / &quot; + data + &quot; / &quot; + headers); if (checkStatusCode(status)) { resolve(isNewFile); } else { reject(&quot;saveFilePromise: &quot; + filePath + &quot; failed &quot; + status); } }, content, 'application/octet-stream' ); } else { reject(&quot;File Already Exists.&quot;); } }, 1); }); } /** * Persists a given text content to a specified filepath * @name saveTextFilePromise * @method * @memberof IOAPI.web * @param {string} filePath - the full path of the file which will be saved * @param {string} content - content that will be saved * @param {string} overWrite - if true existing file path will be overwritten * @returns {Promise.&lt;Success, Error&gt;} */ function saveTextFilePromise(filePath, content, overWrite) { console.log(&quot;Saving text file: &quot; + filePath); return saveFilePromise(filePath, content, overWrite, &quot;text&quot;); } /** * Persists a given binary content to a specified filepath * @name saveBinaryFilePromise * @method * @memberof IOAPI.web * @param {string} filePath - the full path of the file which will be saved * @param {string} content - content that will be saved * @param {string} overWrite - if true existing file path will be overwritten * @returns {Promise.&lt;Success, Error&gt;} */ function saveBinaryFilePromise(filePath, content, overWrite) { console.log(&quot;Saving binary file: &quot; + filePath); return saveFilePromise(filePath, content, overWrite); } /** * Creates a directory * @name createDirectoryPromise * @method * @memberof IOAPI.web * @param {string} dirPath - the full path of the folder which will be created * @returns {Promise.&lt;Success, Error&gt;} */ function createDirectoryPromise(dirPath) { console.log(&quot;Creating directory: &quot; + dirPath); return new Promise(function(resolve, reject) { davClient.mkcol( encodeURI(dirPath), function(status, data, headers) { console.log(&quot;Directory Creation Status/Content/Headers: &quot; + status + &quot; / &quot; + data + &quot; / &quot; + headers); if (checkStatusCode(status)) { resolve(dirPath); } else { reject(&quot;createDirectory &quot; + dirPath + &quot; failed &quot; + status); } } ); }); } /** * Copies a given file to a specified location * @name copyFilePromise * @method * @memberof IOAPI.web * @param {string} filePath - the full path of a file which will be copied * @param {string} newFilePath - the full path destination of the copied file * @returns {Promise.&lt;Success, Error&gt;} */ function copyFilePromise(filePath, newFilePath) { console.log(&quot;Copying file: &quot; + filePath + &quot; to &quot; + newFilePath); return new Promise(function(resolve, reject) { if (filePath.toLowerCase() === newFilePath.toLowerCase()) { TSCORE.hideWaitingDialog(); TSCORE.showAlertDialog($.i18n.t(&quot;ns.common:fileTheSame&quot;), $.i18n.t(&quot;ns.common:fileNotCopyied&quot;)); reject($.i18n.t(&quot;ns.common:fileTheSame&quot;)); } else { davClient.copy( encodeURI(filePath), function(status, data, headers) { console.log(&quot;Copy File Status/Content/Headers: &quot; + status + &quot; / &quot; + data + &quot; / &quot; + headers); if (checkStatusCode(status)) { resolve(filePath, newFilePath); } else { reject(&quot;copyFile &quot; + filePath + &quot; failed &quot; + status); } }, encodeURI(newFilePath), davClient.FAIL_ON_OVERWRITE ); } }); } /** * Renames a given file * @name renameFilePromise * @method * @memberof IOAPI.web * @param {string} filePath - the full path of the file which will be renamed * @param {string} newFilePath - the desired full path after the file rename * @returns {Promise.&lt;Success, Error&gt;} */ function renameFilePromise(filePath, newFilePath) { console.log(&quot;Renaming file: &quot; + filePath + &quot; to &quot; + newFilePath); return new Promise(function(resolve, reject) { if (filePath === newFilePath) { TSCORE.hideWaitingDialog(); TSCORE.showAlertDialog($.i18n.t(&quot;ns.common:fileTheSame&quot;), $.i18n.t(&quot;ns.common:fileNotMoved&quot;)); reject($.i18n.t(&quot;ns.common:fileTheSame&quot;)); } else { davClient.move( encodeURI(filePath), function(status, data, headers) { console.log(&quot;Rename File Status/Content/Headers: &quot; + status + &quot; / &quot; + data + &quot; / &quot; + headers); if (checkStatusCode(status)) { resolve([filePath, newFilePath]); } else { reject(&quot;rename: &quot; + filePath + &quot; failed &quot; + status); } }, encodeURI(newFilePath), davClient.FAIL_ON_OVERWRITE ); } }); } /** * Rename a directory * @name renameDirectoryPromise * @method * @memberof IOAPI.web * @param {string} dirPath - the full path of the directory which will be renamed * @param {string} newDirPath - the desired full path after the directory rename * @returns {Promise.&lt;Success, Error&gt;} */ function renameDirectoryPromise(dirPath, newDirPath) { var newDirPath = TSCORE.TagUtils.extractParentDirectoryPath(dirPath) + TSCORE.dirSeparator + newDirPath; console.log(&quot;Renaming directory: &quot; + dirPath + &quot; to &quot; + newDirPath); return new Promise(function(resolve, reject) { if (dirPath === newDirPath) { TSCORE.hideWaitingDialog(); TSCORE.showAlertDialog($.i18n.t(&quot;ns.common:fileTheSame&quot;), $.i18n.t(&quot;ns.common:fileNotMoved&quot;)); reject($.i18n.t(&quot;ns.common:fileTheSame&quot;)); } else { davClient.move( encodeURI(dirPath), function(status, data, headers) { console.log(&quot;Rename Directory Status/Content/Headers: &quot; + status + &quot; / &quot; + data + &quot; / &quot; + headers); if (checkStatusCode(status)) { resolve(newDirPath); } else { reject(&quot;rename: &quot; + dirPath + &quot; failed &quot; + status); } }, encodeURI(newDirPath), davClient.FAIL_ON_OVERWRITE ); } }); } /** * Delete a specified file * @name deleteFilePromise * @method * @memberof IOAPI.web * @param {string} path - the full path of the file which will be deleted * @returns {Promise.&lt;Success, Error&gt;} */ function deleteFilePromise(path) { // return deleteDirectoryPromise(path); } /** * Delete a specified directory, the directory should be empty, if the trash can functionality is not enabled * @name deleteDirectoryPromise * @method * @memberof IOAPI.web * @param {string} path - the full path of the directory which will be deleted * @returns {Promise.&lt;Success, Error&gt;} */ function deleteDirectoryPromise(path) { return new Promise(function(resolve, reject) { davClient.remove( encodeURI(path), function(status, data, headers) { console.log(&quot;Directory/File Deletion Status/Content/Headers: &quot; + status + &quot; / &quot; + data + &quot; / &quot; + headers); if (checkStatusCode(status)) { resolve(path); } else { reject(&quot;delete &quot; + path + &quot; failed &quot; + status); } } ); }); } /** * Not implemented in the WebDAV version * @name selectDirectory * @method * @memberof IOAPI.web */ function selectDirectory() { // TSCORE.showAlertDialog(&quot;Select directory is still not implemented in the webdav edition&quot;); } /** * Not implemented in the WebDAV version * @name selectFile * @method * @memberof IOAPI.web */ function selectFile() { // TSCORE.showAlertDialog(&quot;selectFile not relevant for webdav&quot;); } /** * Not relevant in the WebDAV version * @name openDirectory * @method * @memberof IOAPI.web * @param {string} dirPath - the full path of the directory which will be opened */ function openDirectory(dirPath) { // TSCORE.showAlertDialog(&quot;openDirectory not relevant for webdav.&quot;); } /** * Not relevant in the WebDAV version * @name openFile * @method * @memberof IOAPI.web * @param {string} filePath - the full path of the file which will be opened */ function openFile(filePath) { // TSCORE.showAlertDialog(&quot;openFile not relevant for webdav&quot;); } // Platform API exports.handleStartParameters = handleStartParameters; exports.focusWindow = focusWindow; exports.checkNewVersion = checkNewVersion; exports.createDirectoryTree = createDirectoryTree; exports.listDirectoryPromise = listDirectoryPromise; exports.getPropertiesPromise = getPropertiesPromise; exports.loadTextFilePromise = loadTextFilePromise; exports.getFileContentPromise = getFileContentPromise; exports.saveFilePromise = saveFilePromise; exports.saveTextFilePromise = saveTextFilePromise; exports.saveBinaryFilePromise = saveBinaryFilePromise; exports.createDirectoryPromise = createDirectoryPromise; exports.copyFilePromise = copyFilePromise; exports.renameFilePromise = renameFilePromise; exports.renameDirectoryPromise = renameDirectoryPromise; exports.deleteFilePromise = deleteFilePromise; exports.deleteDirectoryPromise = deleteDirectoryPromise; exports.selectDirectory = selectDirectory; exports.selectFile = selectFile; exports.openDirectory = openDirectory; exports.openFile = openFile; }); Ã— Search results Close "},"js_core.api.js.html":{"id":"js_core.api.js.html","title":"Source: js/core.api.js","body":" TagSpaces API Classes IOAPIIOAPI.ChromeExtensionIOAPI.CordovaIOAPI.FirefoxAddonIOAPI.NWJSIOAPI.WebDAVTSCORE Source: js/core.api.js /* Copyright (c) 2012-2015 The TagSpaces Authors. All rights reserved. * Use of this source code is governed by a AGPL3 license that * can be found in the LICENSE file. */ /*global isNode, isWin, isFirefox, Mousetrap, gui */ /** * Description * @class TSCORE */ define(function(require, exports, module) { 'use strict'; console.log('Loading core.api.js ...'); var tsSettings = require('tssetting'); var tsIOApi = require('tsioapi'); var tsPersManager = require('tspersmanager'); var tsTagUtils = require('tstagutils'); var tsFileOpener = require('tsfileopener'); var tsTagsUI = require('tstagsui'); var tsDirectoriesUI = require('tsdirectoriesui'); var tsCoreUI = require('tscoreui'); var tsSearch = require('tssearch'); var tsPro = require('tspro'); var tsUtils = require('tsutils'); var tsIOUtils = require('tsioutils'); var tsMeta = require('tsmeta'); var tsExt = require('tsextapi'); var tsExtManager = require('tsextmanager'); var currentPath; var currentLocationObject; var currentPerspectiveID; // Current selected files var selectedFiles = []; // Current directory list of files var fileList = []; // List of the sub directories of the current directory var subDirsList = []; // List of meta files var metaFileList = []; // Last clicked button for removing a tag var selectedTag = ''; var selectedTagData = ''; var startTime; var subfoldersDirBrowser; var directoryBrowser; /** * Initalizes the application * @memberof TSCORE * @method initApp */ function initApp() { console.log('Init application'); tsSettings.loadSettingsLocalStorage(); checkLocalStorageEnabled(); // In firefox, by empty local storage trying to load the settings from mozilla preferences if (tsSettings.Settings === undefined &amp;&amp; isFirefox) { window.setTimeout(tsIOApi.loadSettings, 1000); // executes initUI and updateSettingMozillaPreferences by success console.log('Loading setting with from mozilla pref executed with delay...'); } // If still nothing found, loading the default setting from the application's javascript // This is usually the case by a new installation if (tsSettings.Settings === undefined) { tsSettings.Settings = tsSettings.DefaultSettings; } tsSettings.upgradeSettings(); // Init UI components tsCoreUI.initUI(); tsTagsUI.initUI(); tsTagsUI.generateTagGroups(); tsDirectoriesUI.initUI(); tsDirectoriesUI.initLocations(); tsFileOpener.initUI(); tsPersManager.initPerspectives().then(function(result) { console.log(&quot;initPerspectives: &quot; + result); }).catch(function(err) { alert(&quot;initPerspectives: &quot; + err); }); hideLoadingAnimation(); $(document).ready(function() { reLayout(); var language = tsSettings.getInterfaceLangauge(); // &quot;de-DE&quot; var langURLParam = getParameterByName('locale'); if (langURLParam.length &gt; 1) { language = langURLParam; } switchInterfaceLanguage(language); initKeyBindings(); tsIOApi.checkAccessFileURLAllowed ? tsIOApi.checkAccessFileURLAllowed() : true; // Show welcome dialog of first start if (tsSettings.isFirstRun()) { tsCoreUI.showWelcomeDialog(); } // Show welcome dialog by no locations if (tsSettings.Settings.tagspacesList.length &lt; 1) { tsCoreUI.startGettingStartedTour(); } if (isNode || isChrome || isElectron || isWeb) { // Handle command line argument in node-webkit tsIOApi.handleStartParameters(); // Handle minimizing to the tray in node-webkit } console.log('Docoument ready finished. Layout initialized'); checkForNewVersion(); }); } function switchInterfaceLanguage(language) { $.i18n.init({ ns: { namespaces: [ 'ns.common', 'ns.dialogs', 'ns.perspectiveList', 'ns.pro', ] }, lng: language, debug: true, fallbackLng: 'en_US' }, function() { $('[data-i18n]').i18n(); if (isNode || isElectron) { tsIOApi.initMainMenu(); } }); exports.currentLanguage = language; } function initKeyBindings() { if (isNode) { var win = gui.Window.get(); Mousetrap.bind(tsSettings.getOpenDevToolsScreenKeyBinding(), function() { win.showDevTools(); }); Mousetrap.bind(tsSettings.getReloadApplicationKeyBinding(), function() { win.reloadIgnoringCache(); }); Mousetrap.bind(tsSettings.getToggleFullScreenKeyBinding(), function() { win.toggleFullscreen(); }); } Mousetrap.bind(tsSettings.getShowTagLibraryKeyBinding(), function() { tsCoreUI.showTagsPanel(); }); Mousetrap.bind(tsSettings.getShowFolderNavigatorBinding(), function() { tsCoreUI.showLocationsPanel(); }); Mousetrap.bind(tsSettings.getAddRemoveTagsKeyBinding(), function() { tsTagsUI.showAddTagsDialog(); }); Mousetrap.bind(tsSettings.getSearchKeyBinding(), function() { tsCoreUI.showSearchArea(); }); } // TODO function checkForNewVersion() { if (tsSettings.getCheckForUpdates()) { tsIOApi.checkNewVersion(); } } function checkLocalStorageEnabled() { var val = 'tagspaces'; try { localStorage.setItem(val, val); localStorage.removeItem(val); } catch (e) { tsCoreUI.showAlertDialog($.i18n.t('ns.dialogs:enableLocalStorageAlert'), 'Error'); } } function getParameterByName(name) { name = name.replace(/[\\[]/, '\\\\[').replace(/[\\]]/, '\\\\]'); var regex = new RegExp('[\\\\?&amp;]' + name + '=([^&amp;#]*)'), results = regex.exec(location.search); return results === null ? '' : decodeURIComponent(results[1].replace(/\\+/g, ' ')); } function updateNewVersionData(data) { console.log('Version Information: ' + data); var versioningData = JSON.parse(data); // Analysing Version Information var availableBuild = parseInt(versioningData.appBuild); var verA = versioningData.appVersion.split('.'); if (verA[1].length == 1) { verA[1] = '0' + verA[1]; } var availableVersion = parseFloat(verA[0] + '.' + verA[1]); var currentBuild = parseInt(tsSettings.DefaultSettings.appBuild); var verC = tsSettings.DefaultSettings.appVersion.split('.'); if (verC[1].length == 1) { verC[1] = '0' + verC[1]; } var currentVersion = parseFloat(verC[0] + '.' + verC[1]); /* Testing the new version notifications availableVersion = 2; currentVersion = 1; availableBuild = 2; currentBuild = 1; */ if (availableVersion &gt; currentVersion || availableVersion == currentVersion &amp;&amp; availableBuild &gt; currentBuild) { $('#newVersionAvailable').css('display', 'block'); $('#whatsNewModal iframe').attr('src', 'http://tagspaces.org/whatsnew/'); $('#whatsNewModal').on('show.bs.modal', function(e) { $('#whatsNewModal iframe').attr('src', 'http://tagspaces.org/whatsnew/'); }); } } function updateLogger() { console.log('Updating logger...'); } var $loadingAnimation = $('.loadingAnimation'); var $statusBar = $('#statusBar'); function showLoadingAnimation() { $statusBar.hide(); $loadingAnimation.show(); } function hideLoadingAnimation() { setTimeout(function() { $loadingAnimation.hide(); $statusBar.show(); }, 500); } function removeFileModel(model, filePath) { console.log('Removing file from model'); for (var i = 0; i &lt; model.length; i++) { if (model[i][exports.fileListFILEPATH] === filePath) { model.splice(i, 1); } } } function updateFileModel(model, oldPath, newPath) { console.log('Removing file from model'); var title = tsTagUtils.extractTitle(newPath), fileExt = tsTagUtils.extractFileExtension(newPath), fileTags = tsTagUtils.extractTags(newPath); for (var i = 0; i &lt; model.length; i++) { if (model[i][exports.fileListFILEPATH] == oldPath) { model[i][exports.fileListFILEPATH] = newPath; model[i][exports.fileListTITLE] = title; model[i][exports.fileListTAGS] = fileTags; model[i][exports.fileListFILEEXT] = fileExt; // TODO complete the list //model[i][exports.fileListFILELMDT] = newPath; //model[i][exports.fileListFILENAME] = newPath; //model[i][exports.fileListFILESIZE] = newPath; } } } function exportFileListCSV(fileList) { var csv = ''; var headers = []; var rows = []; var numberOfTagColumns = 40; // max. estimated to 40 ca. 5 symbols per tag _[er], max. path length 25x chars headers.push('path'); headers.push('title'); headers.push('size'); for (var i = 0; i &lt; numberOfTagColumns; i++) { headers.push('tag' + i); } csv += headers.join(',') + '\\n'; for (var i = 0; i &lt; fileList.length; i++) { var row = fileList[i][exports.fileListFILEPATH] + ',' + fileList[i][exports.fileListTITLE] + ',' + fileList[i][exports.fileListFILESIZE] + ',' + fileList[i][exports.fileListTAGS]; rows.push(row); } csv += rows.join('\\n'); return csv; } function exportFileListArray(fileList) { var rows = []; for (var i = 0; i &lt; fileList.length; i++) { var row = []; row.path = fileList[i][exports.fileListFILEPATH]; row.title = fileList[i][exports.fileListTITLE]; row.size = fileList[i][exports.fileListFILESIZE]; var tags = fileList[i][exports.fileListTAGS]; for (var j = 0; j &lt; tags.length; j++) { row['tag' + j] = tags[j]; } rows.push(row); } return rows; } // UI and Layout functionalities var isFullWidth = false; var shouldOpenCol1 = true; var shouldOpenCol2 = true; var shouldOpenCol3 = false; var oneColumn = false; function isOneColumn() { return oneColumn; } function reLayout() { //console.log(&quot;Window w: &quot;+window.innerWidth+&quot; h: &quot;+window.innerHeight+&quot; orient: &quot;+window.orientation+&quot; dpi: &quot;+window.devicePixelRatio); var fullWidth = window.innerWidth; var halfWidth = Math.round(window.innerWidth / 2); var isPortret = fullWidth &lt; window.innerHeight; oneColumn = fullWidth &lt; 660; var twoColumn = fullWidth &gt;= 660 &amp;&amp; fullWidth &lt; 1024; $(&quot;#searchOptions&quot;).hide(); showPerspectiveMenu(); tsCoreUI.hideAllDropDownMenus(); if (isFullWidth) { oneColumn = true; } if (oneColumn) { if (shouldOpenCol3) { shouldOpenCol1 = false; shouldOpenCol2 = false; } else if (shouldOpenCol1) { shouldOpenCol1 = true; shouldOpenCol2 = true; shouldOpenCol3 = false; hidePerspectiveMenu(); } else { shouldOpenCol2 = true; } if (!isFullWidth) { $('#toggleFullWidthButton').hide(); } } else if (twoColumn) { $(&quot;#openLeftPanel&quot;).show(); shouldOpenCol2 = true; if (shouldOpenCol3) { shouldOpenCol1 = false; shouldOpenCol3 = true; } } else { // three column $('#toggleFullWidthButton').show(); if (isFullWidth) { shouldOpenCol1 = false; shouldOpenCol2 = false; shouldOpenCol3 = true; } else { shouldOpenCol2 = true; } } if (shouldOpenCol1) { $(&quot;#openLeftPanel&quot;).hide(); $(&quot;#closeLeftPanel&quot;).show(); $(&quot;.col1&quot;).show(); } else { $(&quot;#closeLeftPanel&quot;).hide(); $(&quot;#openLeftPanel&quot;).show(); $(&quot;.col1&quot;).hide(); } if (shouldOpenCol2) { //$(&quot;#openLeftPanel&quot;).hide(); $(&quot;.col2&quot;).show(); } else { $(&quot;.col2&quot;).hide(); } if (shouldOpenCol3) { //$(&quot;#openLeftPanel&quot;).hide(); $(&quot;.col3&quot;).show(); hidePerspectiveMenu(); } else { $(&quot;.col3&quot;).hide(); } } function hidePerspectiveMenu() { $(&quot;.perspectiveMainMenuButton&quot;).hide(); } function showPerspectiveMenu() { $(&quot;.perspectiveMainMenuButton&quot;).show(); } //TODO: save state on file operations var saveOpenCol1 = false; function openFileViewer() { shouldOpenCol3 = true; saveOpenCol1 = shouldOpenCol1; reLayout(); } function closeFileViewer() { shouldOpenCol3 = false; isFullWidth = false; reLayout(); } function toggleFullWidth() { isFullWidth = !isFullWidth; shouldOpenCol1 = saveOpenCol1; reLayout(); } function closeLeftPanel() { shouldOpenCol1 = false; reLayout(); } function openLeftPanel() { shouldOpenCol1 = true; reLayout(); } function reloadUI() { location.reload(); } window.addEventListener('orientationchange', reLayout); $(window).on('resize', reLayout); function createDocumentEvent(type, data) { var evt = document.createEvent('Events'); evt.initEvent(type, false, false); return evt; } function fireDocumentEvent(evt) { setTimeout(function() { document.dispatchEvent(evt); }, 0); } // Proxying applications parts exports.Config = tsSettings; exports.IO = tsIOApi; exports.IOUtils = tsIOUtils; exports.UI = tsCoreUI; exports.PerspectiveManager = tsPersManager; exports.TagUtils = tsTagUtils; exports.FileOpener = tsFileOpener; exports.Search = tsSearch; exports.Utils = tsUtils; if (tsPro.available) { exports.PRO = tsPro; } exports.Meta = tsMeta; // Public API definition exports.dirSeparator = isWin &amp;&amp; !isWeb ? '\\\\' : '/'; exports.metaFolder = &quot;.ts&quot;; exports.metaFolderFile = &quot;tsm.json&quot;; exports.metaFileExt = &quot;.json&quot;; exports.thumbFileExt = &quot;.png&quot;; exports.contentFileExt = &quot;.txt&quot;; exports.locationDesktop; exports.initApp = initApp; exports.reLayout = reLayout; exports.isOneColumn = isOneColumn; exports.updateLogger = updateLogger; exports.showLoadingAnimation = showLoadingAnimation; exports.hideLoadingAnimation = hideLoadingAnimation; exports.reloadUI = reloadUI; exports.reLayout = reLayout; exports.openFileViewer = openFileViewer; exports.closeFileViewer = closeFileViewer; exports.openLeftPanel = openLeftPanel; exports.closeLeftPanel = closeLeftPanel; exports.toggleFullWidth = toggleFullWidth; exports.updateNewVersionData = updateNewVersionData; exports.exportFileListCSV = exportFileListCSV; exports.exportFileListArray = exportFileListArray; exports.removeFileModel = removeFileModel; exports.updateFileModel = updateFileModel; exports.switchInterfaceLanguage = switchInterfaceLanguage; exports.getParameterByName = getParameterByName; // Proxying functions from tsCoreUI // TODO use TSCORE.UI instead exports.clearSearchFilter = tsCoreUI.clearSearchFilter; exports.openLinkExternally = tsCoreUI.openLinkExternally; exports.enableTopToolbar = tsCoreUI.enableTopToolbar; exports.disableTopToolbar = tsCoreUI.disableTopToolbar; exports.showAlertDialog = tsCoreUI.showAlertDialog; exports.showSuccessDialog = tsCoreUI.showSuccessDialog; exports.showConfirmDialog = tsCoreUI.showConfirmDialog; exports.showTagEditDialog = tsCoreUI.showTagEditDialog; exports.hideAllDropDownMenus = tsCoreUI.hideAllDropDownMenus; exports.showFileCreateDialog = tsCoreUI.showFileCreateDialog; exports.showFileRenameDialog = tsCoreUI.showFileRenameDialog; exports.showFileDeleteDialog = tsCoreUI.showFileDeleteDialog; exports.showLocationsPanel = tsCoreUI.showLocationsPanel; exports.showTagsPanel = tsCoreUI.showTagsPanel; exports.showContextMenu = tsCoreUI.showContextMenu; exports.showDirectoryBrowserDialog = tsCoreUI.showDirectoryBrowserDialog; exports.createHTMLFile = tsCoreUI.createHTMLFile; exports.createMDFile = tsCoreUI.createMDFile; exports.createTXTFile = tsCoreUI.createTXTFile; exports.showSearchArea = tsCoreUI.showSearchArea; // Proxying functions from tsTagsUI exports.generateTagButtons = tsTagsUI.generateTagButtons; exports.generateTagStyle = tsTagsUI.generateTagStyle; exports.openTagMenu = tsTagsUI.openTagMenu; exports.showWaitingDialog = tsCoreUI.showWaitingDialog; exports.hideWaitingDialog = tsCoreUI.hideWaitingDialog; exports.showMoveCopyFilesDialog = tsCoreUI.showMoveCopyFilesDialog; exports.showAddTagsDialog = tsTagsUI.showAddTagsDialog; exports.showTagEditInTreeDialog = tsTagsUI.showTagEditInTreeDialog; exports.showDialogTagCreate = tsTagsUI.showDialogTagCreate; exports.showDialogEditTagGroup = tsTagsUI.showDialogEditTagGroup; exports.showDialogTagGroupCreate = tsTagsUI.showDialogTagGroupCreate; exports.calculatedTags = tsTagsUI.calculatedTags; exports.locationTags = tsTagsUI.locationTags; exports.generateTagGroups = tsTagsUI.generateTagGroups; // Proxying functions from directoriesUI exports.openLocation = tsDirectoriesUI.openLocation; exports.updateSubDirs = tsDirectoriesUI.updateSubDirs; exports.initLocations = tsDirectoriesUI.initLocations; exports.showCreateDirectoryDialog = tsDirectoriesUI.showCreateDirectoryDialog; exports.closeCurrentLocation = tsDirectoriesUI.closeCurrentLocation; exports.navigateToDirectory = tsDirectoriesUI.navigateToDirectory; exports.generateFolderTags = tsDirectoriesUI.generateFolderTags; // Public variables definition exports.currentPath = currentPath; exports.currentLanguage = exports.currentLanguage; exports.currentLocationObject = currentLocationObject; exports.currentPerspectiveID = currentPerspectiveID; exports.selectedFiles = selectedFiles; exports.fileList = fileList; exports.subDirsList = subDirsList; exports.selectedTag = selectedTag; exports.selectedTagData = selectedTagData; exports.startTime = startTime; exports.subfoldersDirBrowser = subfoldersDirBrowser; exports.directoryBrowser = directoryBrowser; exports.fileListFILEEXT = 0; exports.fileListTITLE = 1; exports.fileListTAGS = 2; exports.fileListFILESIZE = 3; exports.fileListFILELMDT = 4; exports.fileListFILEPATH = 5; exports.fileListFILENAME = 6; exports.fileListMETA = 7; //document events exports.createDocumentEvent = createDocumentEvent; exports.fireDocumentEvent = fireDocumentEvent; exports.metaFileList = metaFileList; }); Ã— Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" TagSpaces API Classes IOAPIIOAPI.ChromeExtensionIOAPI.CordovaIOAPI.FirefoxAddonIOAPI.NWJSIOAPI.WebDAVTSCORE Classes Classes IOAPI ChromeExtension Cordova FirefoxAddon NWJS WebDAV TSCORE Ã— Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" TagSpaces API Classes IOAPIIOAPI.ChromeExtensionIOAPI.CordovaIOAPI.FirefoxAddonIOAPI.NWJSIOAPI.WebDAVTSCORE IntroductionTagSpaces is a open source application for managing of your local files. You can find more information about it on its website tagspaces.org. For a quick TagSpaces introduction please see this video on youtube. TagSpaces blog for any news about tagspaces the issues tracker for developer support requests the TagSpaces wiki for end-users and implementors (currently not really used) To get updates you can: Subscribe to GitHub updates by clicking the &quot;watch&quot; button up the top right of this page. Subscribe to RSS feed updates for the master branch Repository Directory Structure./data...............see the next lines ./data/assets........contains all the css and images used in the application ./data/js............contains the javascript module of the application ./data/libs..........contains external javascript libraries together with the license they are distributed ./data/chromium......contains files specific for the current Chrome browser extension ./data/cordova ......contains files needed for the building of the Android application which is based on Cordova ./data/electron......contains files needed for the Windows, Linux and Mac OS builds of the application ./data/mozilla.......contains files needed for the Firefox extension based on addon sdk ./data/web...........contains files needed for the WebDAV/ownCloud based release of TagSpaces ./data/node-webkit...contains files needed for the Windows, Linux and Mac OS builds of the application ./data/templates.....contains HTML templates needed for the UI ./data/locales.......contains files need for the localisation of the application UI ./data/_locales......contains files need for the localisation of the chrome extension UIDownloadsYou can find the latest release of TagSpace in the github release area of TagSpaces A full list of the changes is available in our changelog Features File managing &amp; tagging: TagSpaces provides a convenient interface for browsing, viewing and tagging of your local files No-Cloud: TagSpaces is running completely serverless on your laptop, desktop or tablet and does not request internet connection or any kind of online registration or service provider. Note Taking: You can create and edit notes in plain text, markdown and html file formats Cross-platform: TagSpaces runs perfectly on Windows, Linux, Mac, Android and as extension in Firefox and Chrome. Screenshots DocumentationThe native Windows, Linux and Mac OS X versions of TagSpaces are built with node-webkit. node-webkit is an app runtime based on Chromium and node.js. You can write native apps in HTML and Javascript with node-webkit. How to run TagSpaces from the source code?Install node.js, npm and git for your platform (e.g. OS X, Windows or Linux). Install bower package manager $ npm install -g bowerGet the TagSpaces source code by cloning its repository: $ git clone https://github.com/tagspaces/tagspaces.gitGo to the data folder and install the TagSpaces extensions with bower: $ cd tagspaces &amp;&amp; cd data $ bower installRun the native Windows, Linux or Mac OS X application with NW.js Download nw.js prebuilt binaries for your system environment. For Windows: copy nw.exe, nw.pak, icudt.dll, ffmpegsumo.dll to tagspaces\\data\\node-webkit directory. For Linux: copy nw, nw.pak, icudtl.dat, libffmpegsumo.so to tagspaces/data/node-webkit directory. If you experience issue related to libudev.so.0 read the following article. For Mac OS X: copy node-webkit.app to tagspaces/data/node-webkit directory. Run the nw executable file. Run the native Windows, Linux or Mac OS X application with Electron Install the electron-prebuilt package with this command: npm install -g electron-prebuilt Goto the folder: cd tagspaces/data/ Execute one of the following commands electron . or npm start Run the Chrome/Chromium extension Go to the chrome Settings and then to Extension Enable the Developer mode checkbox in the upper right part of the screen Click on the Load unpacked extension... button Then select the tagspaces/data directory and click Open Activate the Allow access to file URLs check box in the TagSpaces entry, in order to enable the access to your local file system Start the extension by clicking on the TagSpaces icon in the upper right part of Chrome/Chromium Run the Firefox extension Download and install the Mozilla Addon SDK following this article Start the SDK by executing source bin/activate in the Addon SDK folder Go to the your local tagspaces folder and run the following command, where the -p argument specifies some local firefox profile: $cfx run -p /tmp/mozprofile Start the addon by clicking the TagSpaces icon in the upper right area of Firefox How to setup the WebDAV edition?There is a script in root folder of the repository called webdavserver.js, which can be started with: node webdavserver.jsThis command will start a local node.js based WebDAV server on http://127.0.0.1:8000. Open your browser and enter the following URL: http://127.0.0.1:8000/index.htmlYou will be prompted for user credentials, which are username: demo and password: demo and now you should be able to work with the WebDAV version of TagSpaces. For setting up the WebDAV version on your server, please read Self-hosted TagSpaces with WebDAV from our blogs. LicenseTagSpaces's source code is licensed under the AGPL (GNU Affero General Public License) Version 3, for the license text see LICENSE file. ContributeTagSpaces is an open source software and as such, the code is publicly available on GitHub, and forking is particularly recommended! Still, contribution must be done following some guidelines.Contributor License Agreement The CLA is an agreement commonly used in major open source project, which aims at protecting all parties implied by a contribution : the contributor, the main code author, and above all, the community. The CLA model we have chosen basically tells the following : the contributionâ€™s copyright is shared between the contributor and the main author. This means each party can do whatever she want in term of relicensing with this contributed piece of code. This is important, because, if in the future, the author wants to change the license in something more in favor of the community, a singular contributor cannot block the process. The Contributor License Agreement can be signed online on the following CLA form. TranslationsYou can help the translation of this application in your favorite languages by joining the translations teams on Transifex. Support and BugsIf you are having trouble using TagSpaces or have found a bug or you have some ideas how TagSpaces could be improved: open a ticket on GitHub. Feeds Subscribe to RSS feed updates for the tagspaces blog Subscribe to RSS feed updates for the master branch This files is created and edited in TagSpaces, using the viewerMD and editorText extensions. Ã— Search results Close "},"IOAPI.html":{"id":"IOAPI.html","title":"Class: IOAPI","body":" TagSpaces API Classes IOAPIIOAPI.ChromeExtensionIOAPI.CordovaIOAPI.FirefoxAddonIOAPI.NWJSIOAPI.WebDAVTSCORE Class: IOAPI IOAPI new IOAPI() Description Source: js/ioutils.js, line 6 Classes ChromeExtension Cordova FirefoxAddon NWJS WebDAV Ã— Search results Close "},"IOAPI.ChromeExtension.html":{"id":"IOAPI.ChromeExtension.html","title":"Class: ChromeExtension","body":" TagSpaces API Classes IOAPIIOAPI.ChromeExtensionIOAPI.CordovaIOAPI.FirefoxAddonIOAPI.NWJSIOAPI.WebDAVTSCORE Class: ChromeExtension IOAPI. ChromeExtension new ChromeExtension() A implementation of the IOAPI for the Chrome/Chromium extensions platform Source: chromium/chrome.api.js, line 6 Methods &lt;static&gt; checkNewVersion() Checks if new version is available Source: chromium/chrome.api.js, line 64 &lt;static&gt; copyFilePromise() Not supported on this platform Source: chromium/chrome.api.js, line 288 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; createDirectoryPromise(dirPath) Not supported on this platform Parameters: Name Type Description dirPath string the full path of the folder which will be created Source: chromium/chrome.api.js, line 248 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; createDirectoryTree(dirPath) Creates recursively a tree structure for a given directory path Parameters: Name Type Description dirPath string the full path of the directory for which the tree will be generated Source: chromium/chrome.api.js, line 85 &lt;static&gt; deleteDirectoryPromise() Not supported on this platform Source: chromium/chrome.api.js, line 314 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; deleteFilePromise() Not supported on this platform Source: chromium/chrome.api.js, line 301 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; getFileContentPromise(fullPath, type) Gets the content of file, useful for binary files Parameters: Name Type Description fullPath string the full path of the file which will be loaded type string the type of the XHR response, defaul is arraybuffer Source: chromium/chrome.api.js, line 191 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; getPropertiesPromise(filePath) Finds out the properties of a file or directory such last modification date or file size Parameters: Name Type Description filePath string full path to the file or the directory, which will be analysed Source: chromium/chrome.api.js, line 159 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; listDirectoryPromise(dirPath) Creates a list with containing the files and the sub directories of a given directory Parameters: Name Type Description dirPath string the full path of the directory for which the tree will be generated Source: chromium/chrome.api.js, line 99 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; loadTextFilePromise(filePath) Load the content of a text file Parameters: Name Type Description filePath string the full path of the file which will be loaded Source: chromium/chrome.api.js, line 178 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; openDirectory(dirPath) Not supported on this platform Parameters: Name Type Description dirPath string the full path of the directory which will be opened Source: chromium/chrome.api.js, line 353 &lt;static&gt; openFile(filePath) Not supported on this platform Parameters: Name Type Description filePath string the full path of the file which will be opened Source: chromium/chrome.api.js, line 365 &lt;static&gt; renameDirectoryPromise() Not supported on this platform Source: chromium/chrome.api.js, line 262 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; renameFilePromise() Not supported on this platform Source: chromium/chrome.api.js, line 275 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; saveFilePromise(filePath, content, overwrite) Persists a given content(binary supported) to a specified filepath Parameters: Name Type Description filePath string the full path of the file which should be saved content string content that will be saved overwrite boolean if true existing file path will be overwritten Source: chromium/chrome.api.js, line 224 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; selectDirectory() Selects a directory with the help of a directory chooser Source: chromium/chrome.api.js, line 327 &lt;static&gt; selectFile() Not supported on this platform Source: chromium/chrome.api.js, line 342 Ã— Search results Close "},"IOAPI.Cordova.html":{"id":"IOAPI.Cordova.html","title":"Class: Cordova","body":" TagSpaces API Classes IOAPIIOAPI.ChromeExtensionIOAPI.CordovaIOAPI.FirefoxAddonIOAPI.NWJSIOAPI.WebDAVTSCORE Class: Cordova IOAPI. Cordova new Cordova() A implementation of the IOAPI for the Chrome/Chromium extensions platform Source: cordova/cordova.api.js, line 8 Members &lt;static&gt; focusWindow mthod Bring the TagSpaces window on top of the windows Source: cordova/cordova.api.js, line 349 Methods &lt;static&gt; checkNewVersion() Checks if new version is available Source: cordova/cordova.api.js, line 328 &lt;static&gt; copyFilePromise(filePath, newFilePath) Copies a given file to a specified location Parameters: Name Type Description filePath string the full path of a file which will be copied newFilePath string the full path destination of the copied file Source: cordova/cordova.api.js, line 711 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; createDirectoryPromise(dirPath) Creates a directory Parameters: Name Type Description dirPath string the full path of the folder which will be created Source: cordova/cordova.api.js, line 685 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; createDirectoryTree(dirPath) Creates recursively a tree structure for a given directory path Parameters: Name Type Description dirPath string the full path of the directory for which the tree will be generated Source: cordova/cordova.api.js, line 368 &lt;static&gt; deleteDirectoryPromise(dirPath) Delete a specified directory, the directory should be empty, if the trash can functionality is not enabled Parameters: Name Type Description dirPath string the full path of the directory which will be deleted Source: cordova/cordova.api.js, line 899 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; deleteFilePromise(filePath) Delete a specified file Parameters: Name Type Description filePath string the full path of the file which will be deleted Source: cordova/cordova.api.js, line 866 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; generateDirectoryTree(entries) Creates recursively a tree structure for a given directory path Parameters: Name Type Description entries string //TODO Source: cordova/cordova.api.js, line 209 &lt;static&gt; getFileContentPromise(fullPath, type) Gets the content of file, useful for binary files Parameters: Name Type Description fullPath string the full path of the file which will be loaded type string the type of the XHR response, defaul is arraybuffer Source: cordova/cordova.api.js, line 529 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; getPropertiesPromise(filePath) Finds out the properties of a file or directory such last modification date or file size Parameters: Name Type Description filePath string full path to the file or the directory, which will be analysed Source: cordova/cordova.api.js, line 470 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; listDirectoryPromise(path, lite) Creates a list with containing the files and the sub directories of a given directory Parameters: Name Type Description path string the directory path for which the list will be created lite boolean if true the path to a file thumbnails will be not included in the resultsThis will increase the performance of the function. Source: cordova/cordova.api.js, line 381 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; loadTextFilePromise(filePath) Load the content of a text file Parameters: Name Type Description filePath string the full path of the file which will be loaded Source: cordova/cordova.api.js, line 516 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; openDirectory(dirPath) Opens a directory in the operating system's default file manager Parameters: Name Type Description dirPath string the full path of the directory which will be opened Source: cordova/cordova.api.js, line 958 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; openFile(filePath) Opens a file with the operating system's default program for the type of the file Parameters: Name Type Description filePath string the full path of the file which will be opened Source: cordova/cordova.api.js, line 971 &lt;static&gt; renameDirectoryPromise(dirPath, newDirName) Rename a directory Parameters: Name Type Description dirPath string the full path of the directory which will be renamed newDirName string the desired full path after the directory rename Source: cordova/cordova.api.js, line 812 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; renameFilePromise(filePath, newFilePath) Renames a given file Parameters: Name Type Description filePath string the full path of the file which will be renamed newFilePath string the desired full path after the file rename Source: cordova/cordova.api.js, line 760 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; saveBinaryFilePromise(filePath, content, overWrite) Persists a given binary content to a specified filepath Parameters: Name Type Description filePath string the full path of the file which will be saved content string content that will be saved overWrite string if true existing file path will be overwritten Source: cordova/cordova.api.js, line 669 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; saveFilePromise(filePath, content, overWrite) Persists a given content(binary supported) to a specified filepath Parameters: Name Type Description filePath string the full path of the file which should be saved content string content that will be saved overWrite boolean if true existing file path will be overwritten Source: cordova/cordova.api.js, line 589 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; saveTextFilePromise(filePath, content, overWrite) Persists a given text content to a specified filepath Parameters: Name Type Description filePath string the full path of the file which will be saved content string content that will be saved overWrite string if true existing file path will be overwritten Source: cordova/cordova.api.js, line 647 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; selectDirectory() Selects a directory with the help of a directory chooser Source: cordova/cordova.api.js, line 936 &lt;static&gt; selectFile() Selects a file with the help of a file chooser Source: cordova/cordova.api.js, line 947 Ã— Search results Close "},"IOAPI.FirefoxAddon.html":{"id":"IOAPI.FirefoxAddon.html","title":"Class: FirefoxAddon","body":" TagSpaces API Classes IOAPIIOAPI.ChromeExtensionIOAPI.CordovaIOAPI.FirefoxAddonIOAPI.NWJSIOAPI.WebDAVTSCORE Class: FirefoxAddon IOAPI. FirefoxAddon new FirefoxAddon() A implementation of the IOAPI for the Chrome/Chromium extensions platform Source: mozilla/mozilla.api.js, line 6 Methods &lt;static&gt; checkNewVersion() Checks if new version is available Source: mozilla/mozilla.api.js, line 118 &lt;static&gt; copyFilePromise(filePath, newFilePath) Copies a given file to a specified location Parameters: Name Type Description filePath string the full path of a file which will be copied newFilePath string the full path destination of the copied file Source: mozilla/mozilla.api.js, line 412 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; createDirectory(dirPath, silentMode) Creates a directory Parameters: Name Type Description dirPath string the full path of the folder which will be created silentMode string //TODO Source: mozilla/mozilla.api.js, line 360 &lt;static&gt; createDirectoryPromise(dirPath) Creates a directory Parameters: Name Type Description dirPath string the full path of the folder which will be created Source: mozilla/mozilla.api.js, line 378 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; createDirectoryTree(dirPath) Creates recursively a tree structure for a given directory path Parameters: Name Type Description dirPath string the full path of the directory for which the tree will be generated Source: mozilla/mozilla.api.js, line 207 &lt;static&gt; deleteDirectoryPromise(path) Delete a specified directory, the directory should be empty, if the trash can functionality is not enabled Parameters: Name Type Description path string the full path of the directory which will be deleted Source: mozilla/mozilla.api.js, line 534 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; deleteFilePromise(path) Delete a specified file Parameters: Name Type Description path string the full path of the file which will be deleted Source: mozilla/mozilla.api.js, line 499 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; getFileContentPromise(fullPath, type) Gets the content of file, useful for binary files Parameters: Name Type Description fullPath string the full path of the file which will be loaded type string the type of the XHR response, defaul is arraybuffer Source: mozilla/mozilla.api.js, line 239 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; getPropertiesPromise(filePath) Finds out the properties of a file or directory such last modification date or file size Parameters: Name Type Description filePath string full path to the file or the directory, which will be analysed Source: mozilla/mozilla.api.js, line 171 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; listDirectoryPromise(dirPath) Creates a list with containing the files and the sub directories of a given directory Parameters: Name Type Description dirPath string the directory path which is listed Source: mozilla/mozilla.api.js, line 135 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; loadTextFilePromise(filePath) Load the content of a text file Parameters: Name Type Description filePath string the full path of the file which will be loaded Source: mozilla/mozilla.api.js, line 226 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; openDirectory(dirPath) Opens a directory in the operating system's default file manager Parameters: Name Type Description dirPath string the full path of the directory which will be opened Source: mozilla/mozilla.api.js, line 582 &lt;static&gt; openFile(filePath) Opens a file with the operating system's default program for the type of the file Parameters: Name Type Description filePath string the full path of the file which will be opened Source: mozilla/mozilla.api.js, line 601 &lt;static&gt; renameDirectoryPromise(path) Rename a directory Parameters: Name Type Description path string the full path of the directory which will be renamed Source: mozilla/mozilla.api.js, line 484 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; renameFilePromise(filePath, newPath) Renames a given file Parameters: Name Type Description filePath string the full path of the file which will be renamed newPath string the desired full path after the file rename Source: mozilla/mozilla.api.js, line 447 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; saveBinaryFilePromise(filePath, content, overWrite) Persists a given binary content to a specified filepath Parameters: Name Type Description filePath string the full path of the file which will be saved content string content that will be saved overWrite string if true existing file path will be overwritten Source: mozilla/mozilla.api.js, line 322 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; saveFilePromise(filePath, content, overWrite) Persists a given content(binary supported) to a specified filepath Parameters: Name Type Description filePath string the full path of the file which should be saved content string content that will be saved overWrite boolean if true existing file path will be overwritten Source: mozilla/mozilla.api.js, line 284 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; selectDirectory() Selects a directory with the help of a directory chooser Source: mozilla/mozilla.api.js, line 549 &lt;static&gt; selectFile() Selects a file with the help of a file chooser Source: mozilla/mozilla.api.js, line 565 Ã— Search results Close "},"IOAPI.NWJS.html":{"id":"IOAPI.NWJS.html","title":"Class: NWJS","body":" TagSpaces API Classes IOAPIIOAPI.ChromeExtensionIOAPI.CordovaIOAPI.FirefoxAddonIOAPI.NWJSIOAPI.WebDAVTSCORE Class: NWJS IOAPI. NWJS new NWJS() A implementation of the IOAPI for the nw.js platform Source: node-webkit/node-webkit.api.js, line 10 Methods &lt;static&gt; checkNewVersion() Checks if new version is available Source: node-webkit/node-webkit.api.js, line 207 &lt;static&gt; copyFilePromise(sourceFilePath, targetFilePath) Copies a given file to a specified location Parameters: Name Type Description sourceFilePath string the full path of a file which will be copied targetFilePath string the full path destination of the copied file Source: node-webkit/node-webkit.api.js, line 441 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; createDirectoryPromise(dirPath) Creates a directory Parameters: Name Type Description dirPath string the full path of the folder which will be created Source: node-webkit/node-webkit.api.js, line 422 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; createDirectoryTree(dirPath) Creates recursively a tree structure for a given directory path Parameters: Name Type Description dirPath string the full path of the directory for which the tree will be generated Source: node-webkit/node-webkit.api.js, line 228 &lt;static&gt; deleteDirectoryPromise(path) Delete a specified directory, the directory should be empty, if the trash can functionality is not enabled Parameters: Name Type Description path string the full path of the directory which will be deleted Source: node-webkit/node-webkit.api.js, line 725 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; deleteFilePromise(path) Delete a specified file Parameters: Name Type Description path string the full path of the file which will be deleted Source: node-webkit/node-webkit.api.js, line 694 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; getFileContentPromise(fullPath, type) Gets the content of file, useful for binary files Parameters: Name Type Description fullPath string the full path of the file which will be loaded type string the type of the XHR response, defaul is arraybuffer Source: node-webkit/node-webkit.api.js, line 587 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; getPropertiesPromise(path) Finds out the properties of a file or directory such last modification date or file size Parameters: Name Type Description path string full path to the file or the directory, which will be analysed Source: node-webkit/node-webkit.api.js, line 375 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; listDirectoryPromise(path, lite) Creates a list with containing the files and the sub directories of a given directory Parameters: Name Type Description path string the directory path which is listed lite boolean if true the path to a file thumbnails will be not included in the resultsThis will increase the performance of the function. Source: node-webkit/node-webkit.api.js, line 309 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; listDirectoryPromiseAsync(path) Creates a list with containing the files and the sub directories of a given directory Parameters: Name Type Description path string the directory path for which the list will be created Source: node-webkit/node-webkit.api.js, line 276 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; loadTextFilePromise(filePath, isPreview) Load the content of a text file Parameters: Name Type Description filePath string the full path of the file which will be loaded isPreview boolean loads only begin of a file (first 10000 bytes) usefull for previewing of the file Source: node-webkit/node-webkit.api.js, line 549 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; openDirectory(dirPath) Opens a directory in the operating system's default file manager Parameters: Name Type Description dirPath string the full path of the directory which will be opened Source: node-webkit/node-webkit.api.js, line 785 &lt;static&gt; openFile(filePath) Opens a file with the operating system's default program for the type of the file Parameters: Name Type Description filePath string the full path of the file which will be opened Source: node-webkit/node-webkit.api.js, line 797 &lt;static&gt; renameDirectoryPromise(dirPath, newDirName) Rename a directory Parameters: Name Type Description dirPath string the full path of the directory which will be renamed newDirName string the desired full path after the directory rename Source: node-webkit/node-webkit.api.js, line 515 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; renameFilePromise(filePath, newFilePath) Renames a given file Parameters: Name Type Description filePath string the full path of the file which will be renamed newFilePath string the desired full path after the file rename Source: node-webkit/node-webkit.api.js, line 485 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; saveBinaryFilePromise(filePath, content, overwrite) Persists a given binary content to a specified filepath Parameters: Name Type Description filePath string the full path of the file which will be saved content string content that will be saved overwrite string if true existing file path will be overwritten Source: node-webkit/node-webkit.api.js, line 678 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; saveFilePromise(filePath, content, overwrite) Persists a given content(binary supported) to a specified filepath Parameters: Name Type Description filePath string the full path of the file which should be saved content string content that will be saved overwrite boolean if true existing file path will be overwritten Source: node-webkit/node-webkit.api.js, line 619 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; saveTextFilePromise(filePath, content, overwrite) Persists a given text content to a specified filepath Parameters: Name Type Description filePath string the full path of the file which will be saved content string content that will be saved overwrite string if true existing file path will be overwritten Source: node-webkit/node-webkit.api.js, line 653 Returns: Type Promise.&lt;Success, Error&gt; &lt;static&gt; selectDirectory() Selects a directory with the help of a directory chooser Source: node-webkit/node-webkit.api.js, line 749 &lt;static&gt; selectFile() Selects a file with the help of a file chooser Source: node-webkit/node-webkit.api.js, line 768 Ã— Search results Close "},"IOAPI.WebDAV.html":{"id":"IOAPI.WebDAV.html","title":"Class: WebDAV","body":" TagSpaces API Classes IOAPIIOAPI.ChromeExtensionIOAPI.CordovaIOAPI.FirefoxAddonIOAPI.NWJSIOAPI.WebDAVTSCORE Class: WebDAV IOAPI. WebDAV new WebDAV() A implementation of the IOAPI for the Chrome/Chromium extensions platform Source: web/web.api.js, line 5 Ã— Search results Close "},"TSCORE.html":{"id":"TSCORE.html","title":"Class: TSCORE","body":" TagSpaces API Classes IOAPIIOAPI.ChromeExtensionIOAPI.CordovaIOAPI.FirefoxAddonIOAPI.NWJSIOAPI.WebDAVTSCORE Class: TSCORE TSCORE new TSCORE() Description Source: js/core.api.js, line 6 Methods &lt;static&gt; initApp() Initalizes the application Source: js/core.api.js, line 46 Ã— Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
